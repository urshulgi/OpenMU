// <copyright file="ClientToServerPacketsRef.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (rebuild this project).
// </auto-generated>
//------------------------------------------------------------------------------

namespace MUnique.OpenMU.Network.Packets.ClientToServer;

using System;
using static System.Buffers.Binary.BinaryPrimitives;

/// <summary>
/// Is sent by the client when: This packet is sent by the client every few seconds. It contains the current "TickCount" of the client operating system and the attack speed of the selected character.
/// Causes reaction on server side: By the original server this is used to detect speed hacks.
/// </summary>
public readonly ref struct PingRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PingRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PingRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PingRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PingRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x0E;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the tick count.
    /// </summary>
    public uint TickCount
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the attack speed.
    /// </summary>
    public ushort AttackSpeed
    {
        get => ReadUInt16LittleEndian(this._data[8..]);
        set => WriteUInt16LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="Ping"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PingRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="Ping"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PingRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: This packet is sent by the client as a response to a request with a challenge value.
/// Causes reaction on server side: By the original server, this is used to detect a modified client.
/// </summary>
public readonly ref struct ChecksumResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ChecksumResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ChecksumResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ChecksumResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ChecksumResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the checksum.
    /// </summary>
    public uint Checksum
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ChecksumResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ChecksumResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ChecksumResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ChecksumResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player sends a public chat message.
/// Causes reaction on server side: The message is forwarded to all surrounding players, including the sender.
/// </summary>
public readonly ref struct PublicChatMessageRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PublicChatMessageRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PublicChatMessageRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PublicChatMessageRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PublicChatMessageRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x00;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the character.
    /// </summary>
    public string Character
    {
        get => this._data.ExtractString(3, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the message.
    /// </summary>
    public string Message
    {
        get => this._data.ExtractString(13, this._data.Length - 13, System.Text.Encoding.UTF8);
        set => this._data.Slice(13).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PublicChatMessage"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PublicChatMessageRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PublicChatMessage"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PublicChatMessageRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 13;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 13;
}


/// <summary>
/// Is sent by the client when: A player sends a private chat message to a specific target player.
/// Causes reaction on server side: The message is forwarded to the target player.
/// </summary>
public readonly ref struct WhisperMessageRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="WhisperMessageRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public WhisperMessageRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="WhisperMessageRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private WhisperMessageRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x02;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the receiver name.
    /// </summary>
    public string ReceiverName
    {
        get => this._data.ExtractString(3, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the message.
    /// </summary>
    public string Message
    {
        get => this._data.ExtractString(13, this._data.Length - 13, System.Text.Encoding.UTF8);
        set => this._data.Slice(13).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="WhisperMessage"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator WhisperMessageRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="WhisperMessage"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(WhisperMessageRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 13;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 13;
}


/// <summary>
/// Is sent by the client when: The player tries to log into the game.
/// Causes reaction on server side: The server is authenticating the sent login name and password. If it's correct, the state of the player is proceeding to be logged in.
/// </summary>
public readonly ref struct LoginLongPasswordRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LoginLongPasswordRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LoginLongPasswordRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LoginLongPasswordRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LoginLongPasswordRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF1;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 60;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the user name, "encrypted" with Xor3.
    /// </summary>
    public Span<byte> Username
    {
        get => this._data.Slice(4, 10);
    }

    /// <summary>
    /// Gets or sets the password, "encrypted" with Xor3.
    /// </summary>
    public Span<byte> Password
    {
        get => this._data.Slice(14, 20);
    }

    /// <summary>
    /// Gets or sets the tick count.
    /// </summary>
    public uint TickCount
    {
        get => ReadUInt32BigEndian(this._data[34..]);
        set => WriteUInt32BigEndian(this._data[34..], value);
    }

    /// <summary>
    /// Gets or sets the client version.
    /// </summary>
    public Span<byte> ClientVersion
    {
        get => this._data.Slice(38, 5);
    }

    /// <summary>
    /// Gets or sets the client serial.
    /// </summary>
    public Span<byte> ClientSerial
    {
        get => this._data.Slice(43, 16);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LoginLongPassword"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LoginLongPasswordRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LoginLongPassword"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LoginLongPasswordRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player tries to log into the game.
/// Causes reaction on server side: The server is authenticating the sent login name and password. If it's correct, the state of the player is proceeding to be logged in.
/// </summary>
public readonly ref struct LoginShortPasswordRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LoginShortPasswordRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LoginShortPasswordRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LoginShortPasswordRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LoginShortPasswordRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF1;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 50;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the user name, "encrypted" with Xor3.
    /// </summary>
    public Span<byte> Username
    {
        get => this._data.Slice(4, 10);
    }

    /// <summary>
    /// Gets or sets the password, "encrypted" with Xor3.
    /// </summary>
    public Span<byte> Password
    {
        get => this._data.Slice(14, 10);
    }

    /// <summary>
    /// Gets or sets the tick count.
    /// </summary>
    public uint TickCount
    {
        get => ReadUInt32BigEndian(this._data[24..]);
        set => WriteUInt32BigEndian(this._data[24..], value);
    }

    /// <summary>
    /// Gets or sets the client version.
    /// </summary>
    public Span<byte> ClientVersion
    {
        get => this._data.Slice(28, 5);
    }

    /// <summary>
    /// Gets or sets the client serial.
    /// </summary>
    public Span<byte> ClientSerial
    {
        get => this._data.Slice(33, 16);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LoginShortPassword"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LoginShortPasswordRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LoginShortPassword"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LoginShortPasswordRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player tries to log into the game.
/// Causes reaction on server side: The server is authenticating the sent login name and password. If it's correct, the state of the player is proceeding to be logged in.
/// </summary>
public readonly ref struct Login075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="Login075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public Login075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="Login075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private Login075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF1;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 48;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the user name, "encrypted" with Xor3.
    /// </summary>
    public Span<byte> Username
    {
        get => this._data.Slice(4, 10);
    }

    /// <summary>
    /// Gets or sets the password, "encrypted" with Xor3.
    /// </summary>
    public Span<byte> Password
    {
        get => this._data.Slice(14, 10);
    }

    /// <summary>
    /// Gets or sets the tick count.
    /// </summary>
    public uint TickCount
    {
        get => ReadUInt32BigEndian(this._data[24..]);
        set => WriteUInt32BigEndian(this._data[24..], value);
    }

    /// <summary>
    /// Gets or sets the client version.
    /// </summary>
    public Span<byte> ClientVersion
    {
        get => this._data.Slice(28, 3);
    }

    /// <summary>
    /// Gets or sets the client serial.
    /// </summary>
    public Span<byte> ClientSerial
    {
        get => this._data.Slice(31, 16);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="Login075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator Login075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="Login075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(Login075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: When the client wants to leave the game in various ways.
/// Causes reaction on server side: Depending on the LogOutType, the game server does several checks and sends a response back to the client. If the request was successful, the game client either closes the game, goes back to server or character selection.
/// </summary>
public readonly ref struct LogOutRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LogOutRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LogOutRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LogOutRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LogOutRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF1;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public LogOutType Type
    {
        get => (LogOutType)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LogOut"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LogOutRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LogOut"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LogOutRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: When the client wants to leave the game in various ways.
/// Causes reaction on server side: Depending on the LogOutType, the game server does several checks and sends a response back to the client. If the request was successful, the game client either closes the game, goes back to server or character selection.
/// </summary>
public readonly ref struct LogOutByCheatDetectionRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LogOutByCheatDetectionRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LogOutByCheatDetectionRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LogOutByCheatDetectionRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LogOutByCheatDetectionRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Type = 4;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF1;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the param.
    /// </summary>
    public byte Param
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LogOutByCheatDetection"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LogOutByCheatDetectionRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LogOutByCheatDetection"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LogOutByCheatDetectionRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: Unknown?
/// Causes reaction on server side: Unknown?
/// </summary>
public readonly ref struct ResetCharacterPointRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ResetCharacterPointRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ResetCharacterPointRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ResetCharacterPointRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ResetCharacterPointRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ResetCharacterPointRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ResetCharacterPointRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ResetCharacterPointRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ResetCharacterPointRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player wants to set a price of an item which is inside his personal item shop.
/// Causes reaction on server side: The price is set for the specified item. Works only if the shop is currently closed.
/// </summary>
public readonly ref struct PlayerShopSetItemPriceRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopSetItemPriceRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopSetItemPriceRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopSetItemPriceRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopSetItemPriceRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the item slot.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the price.
    /// </summary>
    public uint Price
    {
        get => ReadUInt32LittleEndian(this._data[5..]);
        set => WriteUInt32LittleEndian(this._data[5..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopSetItemPrice"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopSetItemPriceRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopSetItemPrice"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PlayerShopSetItemPriceRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player wants to open his personal item shop.
/// Causes reaction on server side: The personal item shop is opened and the surrounding players are informed about it, including the own player.
/// </summary>
public readonly ref struct PlayerShopOpenRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopOpenRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopOpenRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopOpenRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopOpenRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 30;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the store name.
    /// </summary>
    public string StoreName
    {
        get => this._data.ExtractString(4, 26, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 26).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopOpen"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopOpenRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopOpen"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PlayerShopOpenRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player wants to close his personal item shop.
/// Causes reaction on server side: The personal item shop is closed and the surrounding players are informed about it, including the own player.
/// </summary>
public readonly ref struct PlayerShopCloseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopCloseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopCloseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopCloseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopCloseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopClose"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopCloseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopClose"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PlayerShopCloseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player opens a shop of another player.
/// Causes reaction on server side: The list of items is sent back, if the shop of the player is currently open.
/// </summary>
public readonly ref struct PlayerShopItemListRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopItemListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopItemListRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopItemListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopItemListRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x05;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 16;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the player name.
    /// </summary>
    public string PlayerName
    {
        get => this._data.ExtractString(6, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(6, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopItemListRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopItemListRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopItemListRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PlayerShopItemListRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player wants to buy the item of another players shop.
/// Causes reaction on server side: If the buyer has enough money, the item is sold to the player. Both players will get notifications about that.
/// </summary>
public readonly ref struct PlayerShopItemBuyRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopItemBuyRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopItemBuyRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopItemBuyRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopItemBuyRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x06;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 17;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the player name.
    /// </summary>
    public string PlayerName
    {
        get => this._data.ExtractString(6, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(6, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the item slot.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data[16];
        set => this._data[16] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopItemBuyRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopItemBuyRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopItemBuyRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PlayerShopItemBuyRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player closes the dialog of another players shop.
/// Causes reaction on server side: The server handles that by unsubscribing the player from changes of the shop.
/// </summary>
public readonly ref struct PlayerShopCloseOtherRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopCloseOtherRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopCloseOtherRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopCloseOtherRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopCloseOtherRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x07;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 16;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the player name.
    /// </summary>
    public string PlayerName
    {
        get => this._data.ExtractString(6, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(6, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopCloseOther"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopCloseOtherRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopCloseOther"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PlayerShopCloseOtherRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player requests to pick up an item which is laying on the ground in the near of the players character.
/// Causes reaction on server side: If the player is allowed to pick the item up, and is the first player which tried that, it tries to add the item to the inventory. The server sends a response about the result of the request.
/// </summary>
public readonly ref struct PickupItemRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PickupItemRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PickupItemRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PickupItemRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PickupItemRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x22;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the item id.
    /// </summary>
    public ushort ItemId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PickupItemRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PickupItemRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PickupItemRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PickupItemRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player requests to pick up an item which is laying on the ground in the near of the players character.
/// Causes reaction on server side: If the player is allowed to pick the item up, and is the first player which tried that, it tries to add the item to the inventory. The server sends a response about the result of the request.
/// </summary>
public readonly ref struct PickupItemRequest075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PickupItemRequest075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PickupItemRequest075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PickupItemRequest075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PickupItemRequest075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x22;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the item id.
    /// </summary>
    public ushort ItemId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PickupItemRequest075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PickupItemRequest075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PickupItemRequest075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PickupItemRequest075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player requests to drop on item of his inventory on the ground.
/// Causes reaction on server side: When the specified coordinates are valid, and the item is allowed to be dropped, it will be dropped on the ground and the surrounding players are notified.
/// </summary>
public readonly ref struct DropItemRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DropItemRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DropItemRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DropItemRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DropItemRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x23;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the target x.
    /// </summary>
    public byte TargetX
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the target y.
    /// </summary>
    public byte TargetY
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the item slot.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DropItemRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DropItemRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DropItemRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DropItemRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player requests to move an item within or between his available item storage, such as inventory, vault, trade or chaos machine.
/// Causes reaction on server side: 
/// </summary>
public readonly ref struct ItemMoveRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemMoveRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemMoveRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemMoveRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemMoveRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x24;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 19;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the from storage.
    /// </summary>
    public ItemStorageKind FromStorage
    {
        get => (ItemStorageKind)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the from slot.
    /// </summary>
    public byte FromSlot
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(5, 12);
    }

    /// <summary>
    /// Gets or sets the to storage.
    /// </summary>
    public ItemStorageKind ToStorage
    {
        get => (ItemStorageKind)this._data[17];
        set => this._data[17] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the to slot.
    /// </summary>
    public byte ToSlot
    {
        get => this._data[18];
        set => this._data[18] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemMoveRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemMoveRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemMoveRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ItemMoveRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player requests to 'consume' an item. This can be a potion which recovers some kind of attribute, or a jewel to upgrade a target item.
/// Causes reaction on server side: The server tries to 'consume' the specified item and responses accordingly.
/// </summary>
public readonly ref struct ConsumeItemRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ConsumeItemRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ConsumeItemRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ConsumeItemRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ConsumeItemRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x26;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the inventory slot index of the item which should be consumed.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets if the item has an effect on another item, e.g. upgrading it, this field contains the inventory slot index of the target item.
    /// </summary>
    public byte TargetSlot
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets defines how the fruit is used. Only applies, if the the item is a fruit.
    /// </summary>
    public ConsumeItemRequest.FruitUsage FruitConsumption
    {
        get => (ConsumeItemRequest.FruitUsage)this._data[5];
        set => this._data[5] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ConsumeItemRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ConsumeItemRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ConsumeItemRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ConsumeItemRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player requests to 'consume' an item. This can be a potion which recovers some kind of attribute, or a jewel to upgrade a target item.
/// Causes reaction on server side: The server tries to 'consume' the specified item and responses accordingly.
/// </summary>
public readonly ref struct ConsumeItemRequest075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ConsumeItemRequest075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ConsumeItemRequest075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ConsumeItemRequest075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ConsumeItemRequest075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x26;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the inventory slot index of the item which should be consumed.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets if the item has an effect on another item, e.g. upgrading it, this field contains the inventory slot index of the target item.
    /// </summary>
    public byte TargetSlot
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ConsumeItemRequest075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ConsumeItemRequest075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ConsumeItemRequest075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ConsumeItemRequest075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player wants to talk to an NPC.
/// Causes reaction on server side: Based on the NPC type, the server sends a response back to the game client. For example, if it's a merchant NPC, it sends back that a merchant dialog should be opened and which items are offered by this NPC.
/// </summary>
public readonly ref struct TalkToNpcRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TalkToNpcRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TalkToNpcRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TalkToNpcRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TalkToNpcRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x30;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the npc id.
    /// </summary>
    public ushort NpcId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="TalkToNpcRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TalkToNpcRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TalkToNpcRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(TalkToNpcRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player closes the dialog which was opened by an interaction with a NPC.
/// Causes reaction on server side: The server updates the state of the player accordingly.
/// </summary>
public readonly ref struct CloseNpcRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CloseNpcRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CloseNpcRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CloseNpcRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CloseNpcRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x31;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CloseNpcRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CloseNpcRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CloseNpcRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CloseNpcRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player wants to buy an item from an opened NPC merchant.
/// Causes reaction on server side: If the player has enough money, the item is added to the inventory and money is removed. Corresponding messages are sent back to the game client.
/// </summary>
public readonly ref struct BuyItemFromNpcRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="BuyItemFromNpcRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public BuyItemFromNpcRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="BuyItemFromNpcRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private BuyItemFromNpcRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x32;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets item Slot (NPC Store)
    /// </summary>
    public byte ItemSlot
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="BuyItemFromNpcRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator BuyItemFromNpcRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="BuyItemFromNpcRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(BuyItemFromNpcRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player wants to sell an item of his inventory to the opened NPC merchant.
/// Causes reaction on server side: The item is sold for money to the NPC. The item is removed from the inventory and money is added. Corresponding messages are sent back to the game client.
/// </summary>
public readonly ref struct SellItemToNpcRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SellItemToNpcRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SellItemToNpcRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SellItemToNpcRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SellItemToNpcRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x33;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets item Slot (Inventory)
    /// </summary>
    public byte ItemSlot
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SellItemToNpcRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SellItemToNpcRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SellItemToNpcRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SellItemToNpcRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player wants to repair an item of his inventory.
/// Causes reaction on server side: The item is repaired if the player has enough money in its inventory. A corresponding response is sent.
/// </summary>
public readonly ref struct RepairItemRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RepairItemRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RepairItemRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RepairItemRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RepairItemRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x34;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets inventory item slot of the target item. If it's 0xFF, the player wants to repair all items - this is only possible with some opened NPC dialogs. Repairing the pet item slot (8) is only possible when the pet trainer npc is opened.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets if the player repairs it over his inventory, it's true. However, a server should never rely on this flag and do his own checks.
    /// </summary>
    public bool IsSelfRepair
    {
        get => this._data[4..].GetBoolean();
        set => this._data[4..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="RepairItemRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RepairItemRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RepairItemRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(RepairItemRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player selected to warp by selecting an entry in the warp list (configured in game client files).
/// Causes reaction on server side: If the player has enough money and is allowed to enter the map, it's getting moved to there.
/// </summary>
public readonly ref struct WarpCommandRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="WarpCommandRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public WarpCommandRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="WarpCommandRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private WarpCommandRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x8E;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets a command key, which is generated by a 'secret' algorithm. Not considered in OpenMU.
    /// </summary>
    public uint CommandKey
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the index of the entry in the warp list.
    /// </summary>
    public ushort WarpInfoIndex
    {
        get => ReadUInt16LittleEndian(this._data[8..]);
        set => WriteUInt16LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="WarpCommandRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator WarpCommandRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="WarpCommandRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(WarpCommandRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: Usually: When the player enters an area on the game map which is configured as gate at the client data files. In the special case of wizards, this packet is also used for the teleport skill. When this is the case, GateNumber is 0 and the target coordinates are specified.
/// Causes reaction on server side: If the player is allowed to enter the "gate", it's moved to the corresponding exit gate area.
/// </summary>
public readonly ref struct EnterGateRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="EnterGateRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public EnterGateRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="EnterGateRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private EnterGateRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1C;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the gate number.
    /// </summary>
    public ushort GateNumber
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the teleport target x.
    /// </summary>
    public byte TeleportTargetX
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the teleport target y.
    /// </summary>
    public byte TeleportTargetY
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="EnterGateRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator EnterGateRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="EnterGateRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(EnterGateRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: Usually: When the player enters an area on the game map which is configured as gate at the client data files. In the special case of wizards, this packet is also used for the teleport skill. When this is the case, GateNumber is 0 and the target coordinates are specified.
/// Causes reaction on server side: If the player is allowed to enter the "gate", it's moved to the corresponding exit gate area.
/// </summary>
public readonly ref struct EnterGateRequest075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="EnterGateRequest075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public EnterGateRequest075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="EnterGateRequest075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private EnterGateRequest075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1C;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the gate number.
    /// </summary>
    public byte GateNumber
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the teleport target x.
    /// </summary>
    public byte TeleportTargetX
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the teleport target y.
    /// </summary>
    public byte TeleportTargetY
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="EnterGateRequest075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator EnterGateRequest075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="EnterGateRequest075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(EnterGateRequest075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A wizard uses the 'Teleport Ally' skill to teleport a party member of his view range to a nearby coordinate.
/// Causes reaction on server side: If the target player is in the same party and in the range, it will teleported to the specified coordinates.
/// </summary>
public readonly ref struct TeleportTargetRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TeleportTargetRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TeleportTargetRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TeleportTargetRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TeleportTargetRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB0;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16LittleEndian(this._data[3..]);
        set => WriteUInt16LittleEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the teleport target x.
    /// </summary>
    public byte TeleportTargetX
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the teleport target y.
    /// </summary>
    public byte TeleportTargetY
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="TeleportTarget"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TeleportTargetRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TeleportTarget"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(TeleportTargetRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: After the client connected to another server due map change.
/// Causes reaction on server side: The player spawns on the new server.
/// </summary>
public readonly ref struct ServerChangeAuthenticationRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ServerChangeAuthenticationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ServerChangeAuthenticationRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ServerChangeAuthenticationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ServerChangeAuthenticationRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB1;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 69;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the account xor 3.
    /// </summary>
    public Span<byte> AccountXor3
    {
        get => this._data.Slice(4, 12);
    }

    /// <summary>
    /// Gets or sets the character name xor 3.
    /// </summary>
    public Span<byte> CharacterNameXor3
    {
        get => this._data.Slice(16, 12);
    }

    /// <summary>
    /// Gets or sets the auth code 1.
    /// </summary>
    public uint AuthCode1
    {
        get => ReadUInt32LittleEndian(this._data[28..]);
        set => WriteUInt32LittleEndian(this._data[28..], value);
    }

    /// <summary>
    /// Gets or sets the auth code 2.
    /// </summary>
    public uint AuthCode2
    {
        get => ReadUInt32LittleEndian(this._data[32..]);
        set => WriteUInt32LittleEndian(this._data[32..], value);
    }

    /// <summary>
    /// Gets or sets the auth code 3.
    /// </summary>
    public uint AuthCode3
    {
        get => ReadUInt32LittleEndian(this._data[36..]);
        set => WriteUInt32LittleEndian(this._data[36..], value);
    }

    /// <summary>
    /// Gets or sets the auth code 4.
    /// </summary>
    public uint AuthCode4
    {
        get => ReadUInt32LittleEndian(this._data[40..]);
        set => WriteUInt32LittleEndian(this._data[40..], value);
    }

    /// <summary>
    /// Gets or sets the tick count.
    /// </summary>
    public uint TickCount
    {
        get => ReadUInt32LittleEndian(this._data[44..]);
        set => WriteUInt32LittleEndian(this._data[44..], value);
    }

    /// <summary>
    /// Gets or sets the client version.
    /// </summary>
    public Span<byte> ClientVersion
    {
        get => this._data.Slice(48, 5);
    }

    /// <summary>
    /// Gets or sets the client serial.
    /// </summary>
    public Span<byte> ClientSerial
    {
        get => this._data.Slice(53, 16);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ServerChangeAuthentication"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ServerChangeAuthenticationRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ServerChangeAuthentication"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ServerChangeAuthenticationRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player opened a castle siege npc and requests the current castle siege status information.
/// Causes reaction on server side: The server returns the status of the castle siege event.
/// </summary>
public readonly ref struct CastleSiegeStatusRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeStatusRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CastleSiegeStatusRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeStatusRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CastleSiegeStatusRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CastleSiegeStatusRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CastleSiegeStatusRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CastleSiegeStatusRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CastleSiegeStatusRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player opened a castle siege npc to register his guild alliance.
/// Causes reaction on server side: The server returns the result of the castle siege registration.
/// </summary>
public readonly ref struct CastleSiegeRegistrationRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeRegistrationRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CastleSiegeRegistrationRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeRegistrationRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CastleSiegeRegistrationRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CastleSiegeRegistrationRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CastleSiegeRegistrationRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CastleSiegeRegistrationRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CastleSiegeRegistrationRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player opened a castle siege npc to un-register his guild alliance.
/// Causes reaction on server side: The server returns the result of the castle siege un-registration.
/// </summary>
public readonly ref struct CastleSiegeUnregisterRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeUnregisterRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CastleSiegeUnregisterRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeUnregisterRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CastleSiegeUnregisterRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.IsGivingUp = true;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the is giving up.
    /// </summary>
    public bool IsGivingUp
    {
        get => this._data[4..].GetBoolean();
        set => this._data[4..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CastleSiegeUnregisterRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CastleSiegeUnregisterRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CastleSiegeUnregisterRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CastleSiegeUnregisterRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player opened a castle siege npc and requests the state about the own registration.
/// Causes reaction on server side: The server returns the state of the castle siege registration, which includes the number of submitted guild marks.
/// </summary>
public readonly ref struct CastleSiegeRegistrationStateRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeRegistrationStateRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CastleSiegeRegistrationStateRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeRegistrationStateRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CastleSiegeRegistrationStateRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CastleSiegeRegistrationStateRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CastleSiegeRegistrationStateRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CastleSiegeRegistrationStateRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CastleSiegeRegistrationStateRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player opened a castle siege npc and adds a guild mark to his guilds registration.
/// Causes reaction on server side: The server returns a response, which includes the number of submitted guild marks.
/// </summary>
public readonly ref struct CastleSiegeMarkRegistrationRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeMarkRegistrationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CastleSiegeMarkRegistrationRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeMarkRegistrationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CastleSiegeMarkRegistrationRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x04;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the item index.
    /// </summary>
    public byte ItemIndex
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CastleSiegeMarkRegistration"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CastleSiegeMarkRegistrationRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CastleSiegeMarkRegistration"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CastleSiegeMarkRegistrationRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player opened a castle siege npc and requests to buy a gate or statue for a specific position (index)..
/// Causes reaction on server side: The server returns a response.
/// </summary>
public readonly ref struct CastleSiegeDefenseBuyRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeDefenseBuyRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CastleSiegeDefenseBuyRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeDefenseBuyRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CastleSiegeDefenseBuyRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x05;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the npc number.
    /// </summary>
    public uint NpcNumber
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the npc index.
    /// </summary>
    public uint NpcIndex
    {
        get => ReadUInt32LittleEndian(this._data[8..]);
        set => WriteUInt32LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CastleSiegeDefenseBuyRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CastleSiegeDefenseBuyRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CastleSiegeDefenseBuyRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CastleSiegeDefenseBuyRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player opened a castle siege npc and requests to repair a gate or statue at a specific position (index)..
/// Causes reaction on server side: The server returns a response.
/// </summary>
public readonly ref struct CastleSiegeDefenseRepairRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeDefenseRepairRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CastleSiegeDefenseRepairRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeDefenseRepairRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CastleSiegeDefenseRepairRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x06;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the npc number.
    /// </summary>
    public uint NpcNumber
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the npc index.
    /// </summary>
    public uint NpcIndex
    {
        get => ReadUInt32LittleEndian(this._data[8..]);
        set => WriteUInt32LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CastleSiegeDefenseRepairRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CastleSiegeDefenseRepairRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CastleSiegeDefenseRepairRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CastleSiegeDefenseRepairRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player opened a castle siege npc and requests to upgrade a gate or statue at a specific position (index)..
/// Causes reaction on server side: The server returns a response.
/// </summary>
public readonly ref struct CastleSiegeDefenseUpgradeRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeDefenseUpgradeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CastleSiegeDefenseUpgradeRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeDefenseUpgradeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CastleSiegeDefenseUpgradeRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x07;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 20;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the npc number.
    /// </summary>
    public uint NpcNumber
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the npc index.
    /// </summary>
    public uint NpcIndex
    {
        get => ReadUInt32LittleEndian(this._data[8..]);
        set => WriteUInt32LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets or sets the npc upgrade type.
    /// </summary>
    public uint NpcUpgradeType
    {
        get => ReadUInt32LittleEndian(this._data[12..]);
        set => WriteUInt32LittleEndian(this._data[12..], value);
    }

    /// <summary>
    /// Gets or sets the npc upgrade value.
    /// </summary>
    public uint NpcUpgradeValue
    {
        get => ReadUInt32LittleEndian(this._data[16..]);
        set => WriteUInt32LittleEndian(this._data[16..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CastleSiegeDefenseUpgradeRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CastleSiegeDefenseUpgradeRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CastleSiegeDefenseUpgradeRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CastleSiegeDefenseUpgradeRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The guild master opened a castle siege npc to manage the castle.
/// Causes reaction on server side: The server returns the tax information.
/// </summary>
public readonly ref struct CastleSiegeTaxInfoRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeTaxInfoRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CastleSiegeTaxInfoRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeTaxInfoRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CastleSiegeTaxInfoRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x08;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CastleSiegeTaxInfoRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CastleSiegeTaxInfoRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CastleSiegeTaxInfoRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CastleSiegeTaxInfoRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The guild master wants to change the tax rate in the castle npc.
/// Causes reaction on server side: The server changes the tax rates accordingly.
/// </summary>
public readonly ref struct CastleSiegeTaxChangeRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeTaxChangeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CastleSiegeTaxChangeRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeTaxChangeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CastleSiegeTaxChangeRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x09;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets 0=Undefined, 1=ChaosMachine, 2 = Normal, 3 = EntranceFeeLandOfTrials
    /// </summary>
    public byte TaxType
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the tax rate.
    /// </summary>
    public uint TaxRate
    {
        get => ReadUInt32BigEndian(this._data[5..]);
        set => WriteUInt32BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CastleSiegeTaxChangeRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CastleSiegeTaxChangeRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CastleSiegeTaxChangeRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CastleSiegeTaxChangeRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The guild master wants to withdraw the tax money from the castle npc.
/// Causes reaction on server side: The server moves the money into the inventory of the guild master.
/// </summary>
public readonly ref struct CastleSiegeTaxMoneyWithdrawRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeTaxMoneyWithdrawRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CastleSiegeTaxMoneyWithdrawRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeTaxMoneyWithdrawRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CastleSiegeTaxMoneyWithdrawRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x10;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the amount.
    /// </summary>
    public uint Amount
    {
        get => ReadUInt32BigEndian(this._data[4..]);
        set => WriteUInt32BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CastleSiegeTaxMoneyWithdraw"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CastleSiegeTaxMoneyWithdrawRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CastleSiegeTaxMoneyWithdraw"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CastleSiegeTaxMoneyWithdrawRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The guild member of the castle owner wants to toggle the gate switch.
/// Causes reaction on server side: The castle gate is getting opened or closed.
/// </summary>
public readonly ref struct ToggleCastleGateRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ToggleCastleGateRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ToggleCastleGateRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ToggleCastleGateRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ToggleCastleGateRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x12;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the close state.
    /// </summary>
    public bool CloseState
    {
        get => this._data[4..].GetBoolean();
        set => this._data[4..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the gate id.
    /// </summary>
    public ushort GateId
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ToggleCastleGateRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ToggleCastleGateRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ToggleCastleGateRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ToggleCastleGateRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The guild master sent a command to his guild during the castle siege event.
/// Causes reaction on server side: The command is shown on the mini map of the guild members.
/// </summary>
public readonly ref struct CastleGuildCommandRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleGuildCommandRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CastleGuildCommandRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleGuildCommandRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CastleGuildCommandRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x1D;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets team Number 0 to 7.
    /// </summary>
    public byte Team
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets 0 = Attack, 1 = Defend, 2 = Wait
    /// </summary>
    public byte Command
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CastleGuildCommand"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CastleGuildCommandRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CastleGuildCommand"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CastleGuildCommandRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A guild member of the castle owners wants to enter the hunting zone (e.g. Land of Trials).
/// Causes reaction on server side: The server changes the entrance setting of the hunting zone.
/// </summary>
public readonly ref struct CastleSiegeHuntingZoneEntranceSettingRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeHuntingZoneEntranceSettingRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CastleSiegeHuntingZoneEntranceSettingRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeHuntingZoneEntranceSettingRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CastleSiegeHuntingZoneEntranceSettingRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x1F;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the is public.
    /// </summary>
    public bool IsPublic
    {
        get => this._data[4..].GetBoolean();
        set => this._data[4..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CastleSiegeHuntingZoneEntranceSetting"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CastleSiegeHuntingZoneEntranceSettingRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CastleSiegeHuntingZoneEntranceSetting"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CastleSiegeHuntingZoneEntranceSettingRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The guild master opened the castle npc and the client needs a list of all gates.
/// Causes reaction on server side: The server returns the list of gates and their status.
/// </summary>
public readonly ref struct CastleSiegeGateListRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeGateListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CastleSiegeGateListRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeGateListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CastleSiegeGateListRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CastleSiegeGateListRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CastleSiegeGateListRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CastleSiegeGateListRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CastleSiegeGateListRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The guild master opened the castle npc and the client needs a list of all statues.
/// Causes reaction on server side: The server returns the list of statues and their status.
/// </summary>
public readonly ref struct CastleSiegeStatueListRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeStatueListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CastleSiegeStatueListRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeStatueListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CastleSiegeStatueListRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CastleSiegeStatueListRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CastleSiegeStatueListRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CastleSiegeStatueListRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CastleSiegeStatueListRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The guild master opened an npc and needs the list of registered guilds for the next siege.
/// Causes reaction on server side: The server returns the list of guilds for the next siege.
/// </summary>
public readonly ref struct CastleSiegeRegisteredGuildsListRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeRegisteredGuildsListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CastleSiegeRegisteredGuildsListRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeRegisteredGuildsListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CastleSiegeRegisteredGuildsListRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB4;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CastleSiegeRegisteredGuildsListRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CastleSiegeRegisteredGuildsListRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CastleSiegeRegisteredGuildsListRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CastleSiegeRegisteredGuildsListRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The guild master opened an npc and needs the list of current guilds which are the castle owners.
/// Causes reaction on server side: The server returns the list of guilds which are the castle owners.
/// </summary>
public readonly ref struct CastleOwnerListRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleOwnerListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CastleOwnerListRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleOwnerListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CastleOwnerListRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB5;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CastleOwnerListRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CastleOwnerListRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CastleOwnerListRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CastleOwnerListRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player wants to fire a catapult during the castle siege event.
/// Causes reaction on server side: The server fires the catapult.
/// </summary>
public readonly ref struct FireCatapultRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FireCatapultRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FireCatapultRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FireCatapultRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private FireCatapultRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB7;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the catapult id.
    /// </summary>
    public ushort CatapultId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the target area index.
    /// </summary>
    public byte TargetAreaIndex
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="FireCatapultRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator FireCatapultRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="FireCatapultRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(FireCatapultRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: After the player fired a catapult and hit another catapult.
/// Causes reaction on server side: The server damages the other catapult.
/// </summary>
public readonly ref struct WeaponExplosionRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="WeaponExplosionRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public WeaponExplosionRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="WeaponExplosionRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private WeaponExplosionRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB7;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x04;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the catapult id.
    /// </summary>
    public ushort CatapultId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="WeaponExplosionRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator WeaponExplosionRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="WeaponExplosionRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(WeaponExplosionRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The client requests the guild logo of the current castle owner guild.
/// Causes reaction on server side: The server returns the guild logo.
/// </summary>
public readonly ref struct GuildLogoOfCastleOwnerRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildLogoOfCastleOwnerRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildLogoOfCastleOwnerRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildLogoOfCastleOwnerRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildLogoOfCastleOwnerRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB9;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildLogoOfCastleOwnerRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildLogoOfCastleOwnerRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildLogoOfCastleOwnerRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildLogoOfCastleOwnerRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A guild member of the castle owners wants to enter the hunting zone (e.g. Land of Trials).
/// Causes reaction on server side: The server takes the entrance money, puts it into the tax wallet and warps the player to the hunting zone.
/// </summary>
public readonly ref struct CastleSiegeHuntingZoneEnterRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeHuntingZoneEnterRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CastleSiegeHuntingZoneEnterRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CastleSiegeHuntingZoneEnterRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CastleSiegeHuntingZoneEnterRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xB9;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x05;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the money.
    /// </summary>
    public uint Money
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CastleSiegeHuntingZoneEnterRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CastleSiegeHuntingZoneEnterRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CastleSiegeHuntingZoneEnterRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CastleSiegeHuntingZoneEnterRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player enters the crywolf map.
/// Causes reaction on server side: The server returns data about the state of the crywolf map.
/// </summary>
public readonly ref struct CrywolfInfoRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CrywolfInfoRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CrywolfInfoRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CrywolfInfoRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CrywolfInfoRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBD;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CrywolfInfoRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CrywolfInfoRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CrywolfInfoRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CrywolfInfoRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player wants to make a contract at the crywolf statue for the crywolf event.
/// Causes reaction on server side: The server tries to enter a contract with the player and the specified statue.
/// </summary>
public readonly ref struct CrywolfContractRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CrywolfContractRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CrywolfContractRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CrywolfContractRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CrywolfContractRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBD;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the statue id.
    /// </summary>
    public ushort StatueId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CrywolfContractRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CrywolfContractRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CrywolfContractRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CrywolfContractRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player opens an item crafting dialog, e.g. the chaos machine.
/// Causes reaction on server side: The server returns data about the state of the benefit of the crywolf event. If it was won before, the chaos rate wents up a few percent.
/// </summary>
public readonly ref struct CrywolfChaosRateBenefitRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CrywolfChaosRateBenefitRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CrywolfChaosRateBenefitRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CrywolfChaosRateBenefitRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CrywolfChaosRateBenefitRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBD;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x09;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CrywolfChaosRateBenefitRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CrywolfChaosRateBenefitRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CrywolfChaosRateBenefitRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CrywolfChaosRateBenefitRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: ?.
/// Causes reaction on server side: ?.
/// </summary>
public readonly ref struct WhiteAngelItemRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="WhiteAngelItemRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public WhiteAngelItemRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="WhiteAngelItemRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private WhiteAngelItemRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD0;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="WhiteAngelItemRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator WhiteAngelItemRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="WhiteAngelItemRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(WhiteAngelItemRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player is running the quest "Infiltrate The Barracks of Balgass" (nr. 5), talking to the Werewolf npc in Crywolf.
/// Causes reaction on server side: It will warp the player to the map 'Barracks of Balgass' where the required monsters have to be killed to proceed with the quest.
/// </summary>
public readonly ref struct EnterOnWerewolfRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="EnterOnWerewolfRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public EnterOnWerewolfRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="EnterOnWerewolfRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private EnterOnWerewolfRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD0;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x07;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="EnterOnWerewolfRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator EnterOnWerewolfRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="EnterOnWerewolfRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(EnterOnWerewolfRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player is running the quest "Into the 'Darkness' Zone" (nr. 6), talking to the gatekeeper npc in 'Barracks of Balgass'.
/// Causes reaction on server side: It will warp the player to the map 'Balgass Refuge' where the required monsters have to be killed to proceed with the quest.
/// </summary>
public readonly ref struct EnterOnGatekeeperRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="EnterOnGatekeeperRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public EnterOnGatekeeperRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="EnterOnGatekeeperRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private EnterOnGatekeeperRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD0;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x08;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="EnterOnGatekeeperRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator EnterOnGatekeeperRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="EnterOnGatekeeperRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(EnterOnGatekeeperRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player talks to the npc "Leo the Helper" and requests an item.
/// Causes reaction on server side: The item will drop on the ground.
/// </summary>
public readonly ref struct LeoHelperItemRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LeoHelperItemRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LeoHelperItemRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LeoHelperItemRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LeoHelperItemRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD0;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x09;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LeoHelperItemRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LeoHelperItemRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LeoHelperItemRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LeoHelperItemRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player talks to the npc "Snowman" in Santa Village and requests to warp back to devias.
/// Causes reaction on server side: The player will be warped back to Devias.
/// </summary>
public readonly ref struct MoveToDeviasBySnowmanRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MoveToDeviasBySnowmanRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MoveToDeviasBySnowmanRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MoveToDeviasBySnowmanRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MoveToDeviasBySnowmanRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD0;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0A;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MoveToDeviasBySnowmanRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MoveToDeviasBySnowmanRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MoveToDeviasBySnowmanRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MoveToDeviasBySnowmanRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player talks to the npc "Santa Claus" and requests an item.
/// Causes reaction on server side: The item will drop on the ground.
/// </summary>
public readonly ref struct SantaClausItemRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SantaClausItemRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SantaClausItemRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SantaClausItemRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SantaClausItemRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD0;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x10;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SantaClausItemRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SantaClausItemRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SantaClausItemRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SantaClausItemRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player talks with the kanturu entrance npc, and shows the enter dialog.
/// Causes reaction on server side: The server returns data about the state of the kanturu event map.
/// </summary>
public readonly ref struct KanturuInfoRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="KanturuInfoRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public KanturuInfoRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="KanturuInfoRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private KanturuInfoRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD1;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="KanturuInfoRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator KanturuInfoRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="KanturuInfoRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(KanturuInfoRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player requests to enter the kanturu event map.
/// Causes reaction on server side: The server checks, if entrance is possible and acts accordingly.
/// </summary>
public readonly ref struct KanturuEnterRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="KanturuEnterRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public KanturuEnterRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="KanturuEnterRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private KanturuEnterRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD1;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="KanturuEnterRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator KanturuEnterRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="KanturuEnterRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(KanturuEnterRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: ?
/// Causes reaction on server side: ?
/// </summary>
public readonly ref struct RaklionStateInfoRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RaklionStateInfoRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RaklionStateInfoRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RaklionStateInfoRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RaklionStateInfoRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD1;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x10;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="RaklionStateInfoRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RaklionStateInfoRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RaklionStateInfoRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(RaklionStateInfoRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The client needs information about how many cash shop points (WCoinC, WCoinP, GoblinPoints) are available to the player.
/// Causes reaction on server side: The server returns the cash shop points information.
/// </summary>
public readonly ref struct CashShopPointInfoRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CashShopPointInfoRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CashShopPointInfoRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CashShopPointInfoRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CashShopPointInfoRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CashShopPointInfoRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CashShopPointInfoRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CashShopPointInfoRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CashShopPointInfoRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player opens or closes the cash shop dialog.
/// Causes reaction on server side: In case of opening, the server returns if the cash shop is available. If the player is in the safezone, it's not.
/// </summary>
public readonly ref struct CashShopOpenStateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CashShopOpenStateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CashShopOpenStateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CashShopOpenStateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CashShopOpenStateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the is closed.
    /// </summary>
    public bool IsClosed
    {
        get => this._data[4..].GetBoolean();
        set => this._data[4..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CashShopOpenState"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CashShopOpenStateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CashShopOpenState"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CashShopOpenStateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player wants to buy an item in the cash shop.
/// Causes reaction on server side: The item is bought and added to the cash shop item storage of the player.
/// </summary>
public readonly ref struct CashShopItemBuyRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CashShopItemBuyRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CashShopItemBuyRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CashShopItemBuyRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CashShopItemBuyRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 23;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the package main index.
    /// </summary>
    public uint PackageMainIndex
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the category.
    /// </summary>
    public uint Category
    {
        get => ReadUInt32LittleEndian(this._data[8..]);
        set => WriteUInt32LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets or sets the product main index.
    /// </summary>
    public uint ProductMainIndex
    {
        get => ReadUInt32LittleEndian(this._data[12..]);
        set => WriteUInt32LittleEndian(this._data[12..], value);
    }

    /// <summary>
    /// Gets or sets the item index.
    /// </summary>
    public ushort ItemIndex
    {
        get => ReadUInt16LittleEndian(this._data[16..]);
        set => WriteUInt16LittleEndian(this._data[16..], value);
    }

    /// <summary>
    /// Gets or sets the coin index.
    /// </summary>
    public uint CoinIndex
    {
        get => ReadUInt32LittleEndian(this._data[18..]);
        set => WriteUInt32LittleEndian(this._data[18..], value);
    }

    /// <summary>
    /// Gets or sets the mileage flag.
    /// </summary>
    public byte MileageFlag
    {
        get => this._data[22];
        set => this._data[22] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CashShopItemBuyRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CashShopItemBuyRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CashShopItemBuyRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CashShopItemBuyRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player wants to send a gift to another player.
/// Causes reaction on server side: The server buys the item with the credits of the player and sends it as gift to the other player.
/// </summary>
public readonly ref struct CashShopItemGiftRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CashShopItemGiftRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CashShopItemGiftRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CashShopItemGiftRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CashShopItemGiftRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x04;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 234;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the package main index.
    /// </summary>
    public uint PackageMainIndex
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the category.
    /// </summary>
    public uint Category
    {
        get => ReadUInt32LittleEndian(this._data[8..]);
        set => WriteUInt32LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets or sets the product main index.
    /// </summary>
    public uint ProductMainIndex
    {
        get => ReadUInt32LittleEndian(this._data[12..]);
        set => WriteUInt32LittleEndian(this._data[12..], value);
    }

    /// <summary>
    /// Gets or sets the item index.
    /// </summary>
    public ushort ItemIndex
    {
        get => ReadUInt16LittleEndian(this._data[16..]);
        set => WriteUInt16LittleEndian(this._data[16..], value);
    }

    /// <summary>
    /// Gets or sets the coin index.
    /// </summary>
    public uint CoinIndex
    {
        get => ReadUInt32LittleEndian(this._data[18..]);
        set => WriteUInt32LittleEndian(this._data[18..], value);
    }

    /// <summary>
    /// Gets or sets the mileage flag.
    /// </summary>
    public byte MileageFlag
    {
        get => this._data[22];
        set => this._data[22] = value;
    }

    /// <summary>
    /// Gets or sets the gift receiver name.
    /// </summary>
    public string GiftReceiverName
    {
        get => this._data.ExtractString(23, 11, System.Text.Encoding.UTF8);
        set => this._data.Slice(23, 11).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the gift text.
    /// </summary>
    public string GiftText
    {
        get => this._data.ExtractString(34, 200, System.Text.Encoding.UTF8);
        set => this._data.Slice(34, 200).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CashShopItemGiftRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CashShopItemGiftRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CashShopItemGiftRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CashShopItemGiftRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player opened the cash shop dialog or used paging of the storage.
/// Causes reaction on server side: In case of opening, the server returns if the cash shop is available. If the player is in the safezone, it's not.
/// </summary>
public readonly ref struct CashShopStorageListRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CashShopStorageListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CashShopStorageListRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CashShopStorageListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CashShopStorageListRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x05;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the page index.
    /// </summary>
    public uint PageIndex
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the inventory type.
    /// </summary>
    public byte InventoryType
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CashShopStorageListRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CashShopStorageListRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CashShopStorageListRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CashShopStorageListRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player wants to delete an item of the cash shop storage.
/// Causes reaction on server side: The server removes the item from cash shop storage.
/// </summary>
public readonly ref struct CashShopDeleteStorageItemRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CashShopDeleteStorageItemRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CashShopDeleteStorageItemRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CashShopDeleteStorageItemRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CashShopDeleteStorageItemRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0A;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 234;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the base item code.
    /// </summary>
    public uint BaseItemCode
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the main item code.
    /// </summary>
    public uint MainItemCode
    {
        get => ReadUInt32LittleEndian(this._data[8..]);
        set => WriteUInt32LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets or sets the product type.
    /// </summary>
    public byte ProductType
    {
        get => this._data[12];
        set => this._data[12] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CashShopDeleteStorageItemRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CashShopDeleteStorageItemRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CashShopDeleteStorageItemRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CashShopDeleteStorageItemRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player wants to get or consume an item which is in the cash shop storage.
/// Causes reaction on server side: The item is applied or added to the inventory.
/// </summary>
public readonly ref struct CashShopStorageItemConsumeRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CashShopStorageItemConsumeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CashShopStorageItemConsumeRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CashShopStorageItemConsumeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CashShopStorageItemConsumeRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the base item code.
    /// </summary>
    public uint BaseItemCode
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the main item code.
    /// </summary>
    public uint MainItemCode
    {
        get => ReadUInt32LittleEndian(this._data[8..]);
        set => WriteUInt32LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets or sets the item index.
    /// </summary>
    public ushort ItemIndex
    {
        get => ReadUInt16LittleEndian(this._data[12..]);
        set => WriteUInt16LittleEndian(this._data[12..], value);
    }

    /// <summary>
    /// Gets or sets the product type.
    /// </summary>
    public byte ProductType
    {
        get => this._data[14];
        set => this._data[14] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CashShopStorageItemConsumeRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CashShopStorageItemConsumeRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CashShopStorageItemConsumeRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CashShopStorageItemConsumeRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: When the player wants to see through the event item list.
/// Causes reaction on server side: The server sends a list with event items back.
/// </summary>
public readonly ref struct CashShopEventItemListRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CashShopEventItemListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CashShopEventItemListRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CashShopEventItemListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CashShopEventItemListRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD2;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x13;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the category index.
    /// </summary>
    public uint CategoryIndex
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CashShopEventItemListRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CashShopEventItemListRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CashShopEventItemListRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CashShopEventItemListRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player wants to unlock the protected vault with a pin.
/// Causes reaction on server side: The vault lock state on the server is updated. VaultProtectionInformation is sent as response.
/// </summary>
public readonly ref struct UnlockVaultRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="UnlockVaultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public UnlockVaultRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="UnlockVaultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private UnlockVaultRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x83;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the pin.
    /// </summary>
    public ushort Pin
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="UnlockVault"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator UnlockVaultRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="UnlockVault"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(UnlockVaultRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player wants to set a new pin for the vault when it's in unlocked state.
/// Causes reaction on server side: The vault pin is set. VaultProtectionInformation is sent as response.
/// </summary>
public readonly ref struct SetVaultPinRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SetVaultPinRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SetVaultPinRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SetVaultPinRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SetVaultPinRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x83;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 27;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the pin.
    /// </summary>
    public ushort Pin
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the password of the account, which is required to set a new vault pin.
    /// </summary>
    public string Password
    {
        get => this._data.ExtractString(6, 20, System.Text.Encoding.UTF8);
        set => this._data.Slice(6, 20).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SetVaultPin"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SetVaultPinRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SetVaultPin"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SetVaultPinRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player wants to remove the pin for the vault when it's in unlocked state.
/// Causes reaction on server side: The vault pin is removed. VaultProtectionInformation is sent as response.
/// </summary>
public readonly ref struct RemoveVaultPinRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RemoveVaultPinRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RemoveVaultPinRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RemoveVaultPinRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RemoveVaultPinRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x83;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 27;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the password of the account, which is required to remove the vault pin.
    /// </summary>
    public string Password
    {
        get => this._data.ExtractString(6, 20, System.Text.Encoding.UTF8);
        set => this._data.Slice(6, 20).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="RemoveVaultPin"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RemoveVaultPinRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RemoveVaultPin"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(RemoveVaultPinRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player closed an opened vault dialog.
/// Causes reaction on server side: The state on the server is updated.
/// </summary>
public readonly ref struct VaultClosedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="VaultClosedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public VaultClosedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="VaultClosedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private VaultClosedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x82;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="VaultClosed"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator VaultClosedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="VaultClosed"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(VaultClosedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player wants to move money from or to the vault storage.
/// Causes reaction on server side: The money is moved, if possible.
/// </summary>
public readonly ref struct VaultMoveMoneyRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="VaultMoveMoneyRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public VaultMoveMoneyRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="VaultMoveMoneyRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private VaultMoveMoneyRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x81;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the direction.
    /// </summary>
    public VaultMoveMoneyRequest.VaultMoneyMoveDirection Direction
    {
        get => (VaultMoveMoneyRequest.VaultMoneyMoveDirection)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the amount.
    /// </summary>
    public uint Amount
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="VaultMoveMoneyRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator VaultMoveMoneyRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="VaultMoveMoneyRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(VaultMoveMoneyRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: When a player has the Lahap npc dialog open and wants to combine or disband jewel stacks.
/// Causes reaction on server side: If successful, the inventory is updated and the game client gets corresponding responses.
/// </summary>
public readonly ref struct LahapJewelMixRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LahapJewelMixRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LahapJewelMixRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LahapJewelMixRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LahapJewelMixRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBC;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the operation.
    /// </summary>
    public LahapJewelMixRequest.MixType Operation
    {
        get => (LahapJewelMixRequest.MixType)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the item.
    /// </summary>
    public LahapJewelMixRequest.ItemType Item
    {
        get => (LahapJewelMixRequest.ItemType)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the mixing stack size.
    /// </summary>
    public LahapJewelMixRequest.StackSize MixingStackSize
    {
        get => (LahapJewelMixRequest.StackSize)this._data[5];
        set => this._data[5] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the unmixing source slot.
    /// </summary>
    public byte UnmixingSourceSlot
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LahapJewelMixRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LahapJewelMixRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LahapJewelMixRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LahapJewelMixRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: When the player opens the party menu in the game client.
/// Causes reaction on server side: If the player is in a party, the server sends back a list with information about all players of the party.
/// </summary>
public readonly ref struct PartyListRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PartyListRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PartyListRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x42;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PartyListRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PartyListRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PartyListRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PartyListRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A party master wants to kick another player from his party, or when a player wants to kick himself from his party.
/// Causes reaction on server side: If the sending player is the party master, or the player wants to kick himself, the target player is removed from the party.
/// </summary>
public readonly ref struct PartyPlayerKickRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyPlayerKickRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PartyPlayerKickRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyPlayerKickRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PartyPlayerKickRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x43;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the player index.
    /// </summary>
    public byte PlayerIndex
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PartyPlayerKickRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PartyPlayerKickRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PartyPlayerKickRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PartyPlayerKickRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A party master wants to invite another player to his party.
/// Causes reaction on server side: If the requesting player has no party, or is the party master, a request is sent to the target player.
/// </summary>
public readonly ref struct PartyInviteRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyInviteRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PartyInviteRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyInviteRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PartyInviteRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x40;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the target player id.
    /// </summary>
    public ushort TargetPlayerId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PartyInviteRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PartyInviteRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PartyInviteRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PartyInviteRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player was invited by another player to join a party and this player sent the response back.
/// Causes reaction on server side: If the sender accepts the request, it's added to the party.
/// </summary>
public readonly ref struct PartyInviteResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyInviteResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PartyInviteResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyInviteResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PartyInviteResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x41;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the accepted.
    /// </summary>
    public bool Accepted
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the requester id.
    /// </summary>
    public ushort RequesterId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PartyInviteResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PartyInviteResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PartyInviteResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PartyInviteResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player wants to walk on the game map.
/// Causes reaction on server side: The player gets moved on the map, visible for other surrounding players.
/// </summary>
public readonly ref struct WalkRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="WalkRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public WalkRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="WalkRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private WalkRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the source x.
    /// </summary>
    public byte SourceX
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the source y.
    /// </summary>
    public byte SourceY
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the step count.
    /// </summary>
    public byte StepCount
    {
        get => this._data[5..].GetByteValue(4, 0);
        set => this._data[5..].SetByteValue(value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the target rotation.
    /// </summary>
    public byte TargetRotation
    {
        get => this._data[5..].GetByteValue(4, 4);
        set => this._data[5..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the directions of the walking path. The target is calculated by taking the source coordinates and applying the directions to it.
    /// </summary>
    public Span<byte> Directions
    {
        get => this._data.Slice(6);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="WalkRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator WalkRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="WalkRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(WalkRequestRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="Directions"/>.
    /// </summary>
    /// <param name="directionsLength">The length in bytes of <see cref="Directions"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int directionsLength) => directionsLength + 6;
}


/// <summary>
/// Is sent by the client when: A player wants to walk on the game map.
/// Causes reaction on server side: The player gets moved on the map, visible for other surrounding players.
/// </summary>
public readonly ref struct WalkRequest075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="WalkRequest075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public WalkRequest075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="WalkRequest075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private WalkRequest075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the source x.
    /// </summary>
    public byte SourceX
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the source y.
    /// </summary>
    public byte SourceY
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the step count.
    /// </summary>
    public byte StepCount
    {
        get => this._data[5..].GetByteValue(4, 0);
        set => this._data[5..].SetByteValue(value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the target rotation.
    /// </summary>
    public byte TargetRotation
    {
        get => this._data[5..].GetByteValue(4, 4);
        set => this._data[5..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the directions of the walking path. The target is calculated by taking the source coordinates and applying the directions to it.
    /// </summary>
    public Span<byte> Directions
    {
        get => this._data.Slice(6);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="WalkRequest075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator WalkRequest075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="WalkRequest075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(WalkRequest075Ref packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="Directions"/>.
    /// </summary>
    /// <param name="directionsLength">The length in bytes of <see cref="Directions"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int directionsLength) => directionsLength + 6;
}


/// <summary>
/// Is sent by the client when: It's sent when the player performs specific skills.
/// Causes reaction on server side: Usually, the player is moved instantly to the specified coordinates on the current map. In OpenMU, this request is not handled, because it allows hackers to "teleport" to any coordinates.
/// </summary>
public readonly ref struct InstantMoveRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="InstantMoveRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public InstantMoveRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="InstantMoveRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private InstantMoveRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x15;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the target x.
    /// </summary>
    public byte TargetX
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the target y.
    /// </summary>
    public byte TargetY
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="InstantMoveRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator InstantMoveRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="InstantMoveRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(InstantMoveRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player does any kind of animation.
/// Causes reaction on server side: The animation number and rotation is forwarded to all surrounding players.
/// </summary>
public readonly ref struct AnimationRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AnimationRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AnimationRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AnimationRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AnimationRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x18;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the animation number.
    /// </summary>
    public byte AnimationNumber
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AnimationRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AnimationRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AnimationRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AnimationRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: After a successful login or after the player decided to leave the game world to go back to the character selection screen.
/// Causes reaction on server side: The server sends the character list with all available characters.
/// </summary>
public readonly ref struct RequestCharacterListRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RequestCharacterListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RequestCharacterListRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RequestCharacterListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RequestCharacterListRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the language.
    /// </summary>
    public byte Language
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="RequestCharacterList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RequestCharacterListRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RequestCharacterList"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(RequestCharacterListRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The game client is at the character selection screen and the player requests to add a new character.
/// Causes reaction on server side: The server checks if the player is allowed to create the character and sends a response back.
/// </summary>
public readonly ref struct CreateCharacterRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CreateCharacterRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CreateCharacterRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CreateCharacterRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CreateCharacterRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 15;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the name of the character which should be created.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the character class of the character which should be created.
    /// </summary>
    public CharacterClassNumber Class
    {
        get => (CharacterClassNumber)this._data[14..].GetByteValue(6, 2);
        set => this._data[14..].SetByteValue((byte)value, 6, 2);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CreateCharacter"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CreateCharacterRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CreateCharacter"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CreateCharacterRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The game client is at the character selection screen and the player requests to delete an existing character.
/// Causes reaction on server side: The server checks if the player transmitted the correct security code and if the character actually exists. If all is valid, it deletes the character from the account. It then sends a response with a result code back to the game client.
/// </summary>
public readonly ref struct DeleteCharacterRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DeleteCharacterRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DeleteCharacterRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DeleteCharacterRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DeleteCharacterRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 24;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the name of the character which should be deleted.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets a security code (7 bytes long). Some game clients/servers also expect to transmit the account password (up to 20 bytes long) here. In OpenMU, we work with the security here, but are not limiting to a length of 7 bytes.
    /// </summary>
    public string SecurityCode
    {
        get => this._data.ExtractString(14, this._data.Length - 14, System.Text.Encoding.UTF8);
        set => this._data.Slice(14).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DeleteCharacter"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DeleteCharacterRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DeleteCharacter"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DeleteCharacterRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'SecurityCode' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 14;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'SecurityCode' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 14;
}


/// <summary>
/// Is sent by the client when: The player selects a character to enter the game world on the character selection screen.
/// Causes reaction on server side: The player joins the game world with the specified character.
/// </summary>
public readonly ref struct SelectCharacterRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SelectCharacterRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SelectCharacterRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SelectCharacterRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SelectCharacterRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 14;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the name of the character with which the player wants to join the game world
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SelectCharacter"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SelectCharacterRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SelectCharacter"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SelectCharacterRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player focuses (clicks on it) a character with which he plans to enter the game world on the character selection screen.
/// Causes reaction on server side: The server checks if this character exists and sends a response back. If successful, the game client highlights the focused character.
/// </summary>
public readonly ref struct FocusCharacterRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FocusCharacterRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FocusCharacterRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FocusCharacterRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private FocusCharacterRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x15;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 14;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="FocusCharacter"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator FocusCharacterRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="FocusCharacter"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(FocusCharacterRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player decides to add a stat point to a specific stat type, by pressing a plus-button in the character info menu.
/// Causes reaction on server side: The server checks if a level-up-point is available. If yes, it adds the point to the specified stat type. It sends a response back to the client.
/// </summary>
public readonly ref struct IncreaseCharacterStatPointRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IncreaseCharacterStatPointRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IncreaseCharacterStatPointRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IncreaseCharacterStatPointRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IncreaseCharacterStatPointRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x06;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the stat type.
    /// </summary>
    public CharacterStatAttribute StatType
    {
        get => (CharacterStatAttribute)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="IncreaseCharacterStatPoint"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IncreaseCharacterStatPointRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IncreaseCharacterStatPoint"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(IncreaseCharacterStatPointRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player bought or sold an item through his personal shop.
/// Causes reaction on server side: The server sends the inventory list back to the client.
/// </summary>
public readonly ref struct InventoryRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="InventoryRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public InventoryRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="InventoryRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private InventoryRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x10;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="InventoryRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator InventoryRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="InventoryRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(InventoryRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: After the server sent a map change message and the client has initialized the game map visualization.
/// Causes reaction on server side: The character is added to the internal game map and ready to interact with other entities.
/// </summary>
public readonly ref struct ClientReadyAfterMapChangeRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ClientReadyAfterMapChangeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ClientReadyAfterMapChangeRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ClientReadyAfterMapChangeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ClientReadyAfterMapChangeRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x12;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ClientReadyAfterMapChange"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ClientReadyAfterMapChangeRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ClientReadyAfterMapChange"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ClientReadyAfterMapChangeRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: When leaving the game world with a character.
/// Causes reaction on server side: The server saves this configuration in its database.
/// </summary>
public readonly ref struct SaveKeyConfigurationRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SaveKeyConfigurationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SaveKeyConfigurationRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SaveKeyConfigurationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SaveKeyConfigurationRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x30;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the binary data of the key configuration
    /// </summary>
    public Span<byte> Configuration
    {
        get => this._data.Slice(4);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SaveKeyConfiguration"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SaveKeyConfigurationRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SaveKeyConfiguration"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SaveKeyConfigurationRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="Configuration"/>.
    /// </summary>
    /// <param name="configurationLength">The length in bytes of <see cref="Configuration"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int configurationLength) => configurationLength + 4;
}


/// <summary>
/// Is sent by the client when: The player wants to add or increase the level of a specific master skill of the master skill tree.
/// Causes reaction on server side: Adds or increases the master skill level of the specified skill, if the character is allowed to do that. A response is sent back to the client.
/// </summary>
public readonly ref struct AddMasterSkillPointRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddMasterSkillPointRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddMasterSkillPointRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddMasterSkillPointRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddMasterSkillPointRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x52;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AddMasterSkillPoint"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddMasterSkillPointRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddMasterSkillPoint"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AddMasterSkillPointRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player attacks a target without using a skill.
/// Causes reaction on server side: Damage is calculated and the target is hit, if the attack was successful. A response is sent back with the caused damage, and all surrounding players get an animation message.
/// </summary>
public readonly ref struct HitRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="HitRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public HitRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="HitRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private HitRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x11;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the attack animation.
    /// </summary>
    public byte AttackAnimation
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the looking direction.
    /// </summary>
    public byte LookingDirection
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="HitRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator HitRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="HitRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(HitRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player performs a skill with a target, e.g. attacking or buffing.
/// Causes reaction on server side: Damage is calculated and the target is hit, if the attack was successful. A response is sent back with the caused damage, and all surrounding players get an animation message.
/// </summary>
public readonly ref struct TargetedSkillRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TargetedSkillRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TargetedSkillRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TargetedSkillRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TargetedSkillRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x19;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="TargetedSkill"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TargetedSkillRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TargetedSkill"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(TargetedSkillRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player performs a skill with a target, e.g. attacking or buffing.
/// Causes reaction on server side: Damage is calculated and the target is hit, if the attack was successful. A response is sent back with the caused damage, and all surrounding players get an animation message.
/// </summary>
public readonly ref struct TargetedSkill075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TargetedSkill075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TargetedSkill075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TargetedSkill075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TargetedSkill075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x19;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the index of the skill in the skill list.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="TargetedSkill075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TargetedSkill075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TargetedSkill075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(TargetedSkill075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player performs a skill with a target, e.g. attacking or buffing.
/// Causes reaction on server side: Damage is calculated and the target is hit, if the attack was successful. A response is sent back with the caused damage, and all surrounding players get an animation message.
/// </summary>
public readonly ref struct TargetedSkill095Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TargetedSkill095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TargetedSkill095Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TargetedSkill095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TargetedSkill095Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x19;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the index of the skill in the skill list.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="TargetedSkill095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TargetedSkill095Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TargetedSkill095"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(TargetedSkill095Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player cancels a specific magic effect of a skill, usually 'Infinity Arrow' and 'Wizardy Enhance'.
/// Causes reaction on server side: The effect is cancelled and an update is sent to the player and all surrounding players.
/// </summary>
public readonly ref struct MagicEffectCancelRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MagicEffectCancelRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MagicEffectCancelRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MagicEffectCancelRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MagicEffectCancelRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MagicEffectCancelRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MagicEffectCancelRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MagicEffectCancelRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MagicEffectCancelRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player is performing an skill which affects an area of the map.
/// Causes reaction on server side: It's forwarded to all surrounding players, so that the animation is visible. In the original server implementation, no damage is done yet for attack skills - there are separate hit packets.
/// </summary>
public readonly ref struct AreaSkillRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AreaSkillRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AreaSkillRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1E;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the target x.
    /// </summary>
    public byte TargetX
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the target y.
    /// </summary>
    public byte TargetY
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets the extra target id.
    /// </summary>
    public ushort ExtraTargetId
    {
        get => ReadUInt16BigEndian(this._data[10..]);
        set => WriteUInt16BigEndian(this._data[10..], value);
    }

    /// <summary>
    /// Gets or sets animation counter which acts as a reference to the previously sent Area Skill Animation packet.
    /// </summary>
    public byte AnimationCounter
    {
        get => this._data[12];
        set => this._data[12] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AreaSkill"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AreaSkillRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AreaSkill"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AreaSkillRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: An area skill was performed and the client decided to hit a target.
/// Causes reaction on server side: The server is calculating the damage and applying it to the target. The attacker gets a response back with the caused damage.
/// </summary>
public readonly ref struct AreaSkillHitRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillHitRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AreaSkillHitRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillHitRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AreaSkillHitRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xDB;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the target x.
    /// </summary>
    public byte TargetX
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the target y.
    /// </summary>
    public byte TargetY
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets a sequential hit counter which should prevent that hits are sent multiple times.
    /// </summary>
    public byte HitCounter
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets number of targets which will follow in the structure.
    /// </summary>
    public byte TargetCount
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Gets the <see cref="TargetDataRef"/> of the specified index.
    /// </summary>
        public TargetDataRef this[int index] => new (this._data[(9 + index * TargetDataRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AreaSkillHit"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AreaSkillHitRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AreaSkillHit"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AreaSkillHitRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="TargetDataRef"/>.
    /// </summary>
    /// <param name="targetsCount">The count of <see cref="TargetDataRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int targetsCount) => targetsCount * TargetDataRef.Length + 9;


/// <summary>
/// Contains the data of the target.
/// </summary>
public readonly ref struct TargetDataRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TargetDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TargetDataRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets a sequential animation counter which acts as a reference to the previously sent Area Skill Animation packet.
    /// </summary>
    public byte AnimationCounter
    {
        get => this._data[2];
        set => this._data[2] = value;
    }
}
}


/// <summary>
/// Is sent by the client when: A player is performing an skill which affects an area of the map.
/// Causes reaction on server side: It's forwarded to all surrounding players, so that the animation is visible. In the original server implementation, no damage is done yet for attack skills - there are separate hit packets.
/// </summary>
public readonly ref struct AreaSkill075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkill075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AreaSkill075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkill075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AreaSkill075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1E;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the index of the skill in the skill list.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the target x.
    /// </summary>
    public byte TargetX
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the target y.
    /// </summary>
    public byte TargetY
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AreaSkill075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AreaSkill075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AreaSkill075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AreaSkill075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: An area skill was performed and the client decided to hit one or more targets.
/// Causes reaction on server side: The server is calculating the damage and applying it to the targets. The attacker gets a response back with the caused damage.
/// </summary>
public readonly ref struct AreaSkillHit075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillHit075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AreaSkillHit075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillHit075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AreaSkillHit075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1D;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the index of the skill in the skill list.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the target x.
    /// </summary>
    public byte TargetX
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the target y.
    /// </summary>
    public byte TargetY
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the number of targets which are hit.
    /// </summary>
    public byte TargetCount
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets the <see cref="TargetDataRef"/> of the specified index.
    /// </summary>
        public TargetDataRef this[int index] => new (this._data[(7 + index * TargetDataRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AreaSkillHit075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AreaSkillHit075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AreaSkillHit075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AreaSkillHit075Ref packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="TargetDataRef"/>.
    /// </summary>
    /// <param name="targetsCount">The count of <see cref="TargetDataRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int targetsCount) => targetsCount * TargetDataRef.Length + 7;


/// <summary>
/// Contains the data of the target.
/// </summary>
public readonly ref struct TargetDataRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TargetDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TargetDataRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 2;

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }
}
}


/// <summary>
/// Is sent by the client when: A player is performing an skill which affects an area of the map.
/// Causes reaction on server side: It's forwarded to all surrounding players, so that the animation is visible. In the original server implementation, no damage is done yet for attack skills - there are separate hit packets.
/// </summary>
public readonly ref struct AreaSkill095Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkill095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AreaSkill095Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkill095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AreaSkill095Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1E;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the index of the skill in the skill list.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the target x.
    /// </summary>
    public byte TargetX
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the target y.
    /// </summary>
    public byte TargetY
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AreaSkill095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AreaSkill095Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AreaSkill095"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AreaSkill095Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: An area skill was performed and the client decided to hit one or more targets.
/// Causes reaction on server side: The server is calculating the damage and applying it to the targets. The attacker gets a response back with the caused damage.
/// </summary>
public readonly ref struct AreaSkillHit095Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillHit095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AreaSkillHit095Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillHit095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AreaSkillHit095Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1D;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the index of the skill in the skill list.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the target x.
    /// </summary>
    public byte TargetX
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the target y.
    /// </summary>
    public byte TargetY
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the counter.
    /// </summary>
    public byte Counter
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the number of targets which are hit.
    /// </summary>
    public byte TargetCount
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets the <see cref="TargetDataRef"/> of the specified index.
    /// </summary>
        public TargetDataRef this[int index] => new (this._data[(8 + index * TargetDataRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AreaSkillHit095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AreaSkillHit095Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AreaSkillHit095"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AreaSkillHit095Ref packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="TargetDataRef"/>.
    /// </summary>
    /// <param name="targetsCount">The count of <see cref="TargetDataRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int targetsCount) => targetsCount * TargetDataRef.Length + 8;


/// <summary>
/// Contains the data of the target.
/// </summary>
public readonly ref struct TargetDataRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TargetDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TargetDataRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 2;

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }
}
}


/// <summary>
/// Is sent by the client when: A player performs a skill with a target, e.g. attacking or buffing.
/// Causes reaction on server side: Damage is calculated and the target is hit, if the attack was successful. A response is sent back with the caused damage, and all surrounding players get an animation message.
/// </summary>
public readonly ref struct RageAttackRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RageAttackRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RageAttackRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RageAttackRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RageAttackRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x4A;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data[6..]);
        set => WriteUInt16BigEndian(this._data[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="RageAttackRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RageAttackRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RageAttackRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(RageAttackRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player (rage fighter) performs the dark side skill on a target.
/// Causes reaction on server side: The targets (up to 5) are determined and sent back to the player with the RageAttackRangeResponse.
/// </summary>
public readonly ref struct RageAttackRangeRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RageAttackRangeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RageAttackRangeRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RageAttackRangeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RageAttackRangeRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x4B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="RageAttackRangeRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RageAttackRangeRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RageAttackRangeRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(RageAttackRangeRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player wants to cancel the trade.
/// Causes reaction on server side: The trade is cancelled and the previous inventory state is restored.
/// </summary>
public readonly ref struct TradeCancelRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeCancelRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeCancelRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeCancelRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeCancelRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3D;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeCancel"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeCancelRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeCancel"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(TradeCancelRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player presses the trade button.
/// Causes reaction on server side: The state change is forwarded to the trade partner. If both players press the trade button at the same time, the server will try to complete the trade by exchanging the items and money.
/// </summary>
public readonly ref struct TradeButtonStateChangeRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeButtonStateChangeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeButtonStateChangeRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeButtonStateChangeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeButtonStateChangeRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3C;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the new state.
    /// </summary>
    public TradeButtonState NewState
    {
        get => (TradeButtonState)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeButtonStateChange"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeButtonStateChangeRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeButtonStateChange"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(TradeButtonStateChangeRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player requests to open a trade with another player.
/// Causes reaction on server side: The request is forwarded to the requested player.
/// </summary>
public readonly ref struct TradeRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x36;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(TradeRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A requested player responded to a trade request of another player.
/// Causes reaction on server side: When the trade request was accepted, the server tries to open a new trade and sends corresponding responses to both players. 
/// </summary>
public readonly ref struct TradeRequestResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeRequestResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeRequestResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeRequestResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeRequestResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x37;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the trade accepted.
    /// </summary>
    public bool TradeAccepted
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeRequestResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeRequestResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeRequestResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(TradeRequestResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player requests to set an amount of money in the trade.
/// Causes reaction on server side: It's taken from the available money of the inventory. If the new money amount is lower than the amount which was set before, it's added back to the inventory. The trade partner is informed about any change.
/// </summary>
public readonly ref struct SetTradeMoneyRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SetTradeMoneyRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SetTradeMoneyRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SetTradeMoneyRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SetTradeMoneyRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3A;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the amount.
    /// </summary>
    public uint Amount
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SetTradeMoney"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SetTradeMoneyRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SetTradeMoney"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SetTradeMoneyRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player requests to delete a letter.
/// Causes reaction on server side: The letter is getting deleted.
/// </summary>
public readonly ref struct LetterDeleteRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LetterDeleteRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LetterDeleteRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LetterDeleteRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LetterDeleteRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC8;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the letter index.
    /// </summary>
    public ushort LetterIndex
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LetterDeleteRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LetterDeleteRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LetterDeleteRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LetterDeleteRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The game client requests the current list of letters.
/// Causes reaction on server side: The server sends the list of available letters to the client.
/// </summary>
public readonly ref struct LetterListRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LetterListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LetterListRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LetterListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LetterListRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC9;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LetterListRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LetterListRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LetterListRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LetterListRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player wants to send a letter to another players character.
/// Causes reaction on server side: The letter is sent to the other character, if it exists and the player has the required money.
/// </summary>
public readonly ref struct LetterSendRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LetterSendRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LetterSendRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LetterSendRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LetterSendRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC4;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C4HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the letter id.
    /// </summary>
    public uint LetterId
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the receiver.
    /// </summary>
    public string Receiver
    {
        get => this._data.ExtractString(8, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(8, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the title.
    /// </summary>
    public string Title
    {
        get => this._data.ExtractString(18, 60, System.Text.Encoding.UTF8);
        set => this._data.Slice(18, 60).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[78];
        set => this._data[78] = value;
    }

    /// <summary>
    /// Gets or sets the animation.
    /// </summary>
    public byte Animation
    {
        get => this._data[79];
        set => this._data[79] = value;
    }

    /// <summary>
    /// Gets or sets the message length.
    /// </summary>
    public ushort MessageLength
    {
        get => ReadUInt16LittleEndian(this._data[80..]);
        set => WriteUInt16LittleEndian(this._data[80..], value);
    }

    /// <summary>
    /// Gets or sets the message.
    /// </summary>
    public string Message
    {
        get => this._data.ExtractString(82, this._data.Length - 82, System.Text.Encoding.UTF8);
        set => this._data.Slice(82).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LetterSendRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LetterSendRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LetterSendRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LetterSendRequestRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 82;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 82;
}


/// <summary>
/// Is sent by the client when: A player requests to read a specific letter of his letter list.
/// Causes reaction on server side: The server sends the requested letter content back to the game client.
/// </summary>
public readonly ref struct LetterReadRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LetterReadRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LetterReadRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LetterReadRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LetterReadRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC7;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the letter index.
    /// </summary>
    public ushort LetterIndex
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LetterReadRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LetterReadRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LetterReadRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LetterReadRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A guild member wants to kick himself or a guild master wants to kick another player from its guild.
/// Causes reaction on server side: If the player is allowed to kick the player, it's removed from the guild. If the guild master kicks himself, the guild is disbanded. Corresponding responses are sent to all involved players.
/// </summary>
public readonly ref struct GuildKickPlayerRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildKickPlayerRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildKickPlayerRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildKickPlayerRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildKickPlayerRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x53;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the player name.
    /// </summary>
    public string PlayerName
    {
        get => this._data.ExtractString(3, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the security code.
    /// </summary>
    public string SecurityCode
    {
        get => this._data.ExtractString(13, this._data.Length - 13, System.Text.Encoding.UTF8);
        set => this._data.Slice(13).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildKickPlayerRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildKickPlayerRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildKickPlayerRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildKickPlayerRequestRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'SecurityCode' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 13;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'SecurityCode' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 13;
}


/// <summary>
/// Is sent by the client when: A player (non-guild member) requests to join a guild.
/// Causes reaction on server side: The request is forwarded to the guild master. There can only be one request at a time. If the guild master already has an open request, a corresponding response is directly sent back to the requesting player.
/// </summary>
public readonly ref struct GuildJoinRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildJoinRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildJoinRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildJoinRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildJoinRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x50;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the guild master player id.
    /// </summary>
    public ushort GuildMasterPlayerId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildJoinRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildJoinRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildJoinRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildJoinRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A guild master responded to a previously sent request.
/// Causes reaction on server side: If the request was accepted by the guild master, the previously requesting player is added to the guild.
/// </summary>
public readonly ref struct GuildJoinResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildJoinResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildJoinResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildJoinResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildJoinResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x51;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the accepted.
    /// </summary>
    public bool Accepted
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the requester id.
    /// </summary>
    public ushort RequesterId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildJoinResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildJoinResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildJoinResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildJoinResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A guild player opens its guild menu in the game client.
/// Causes reaction on server side: A list of all guild members and their state is sent back as response.
/// </summary>
public readonly ref struct GuildListRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildListRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildListRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x52;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildListRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildListRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildListRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildListRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: When a player wants to create a guild.
/// Causes reaction on server side: The guild is created and the player is set as the new guild master of the guild.
/// </summary>
public readonly ref struct GuildCreateRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildCreateRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildCreateRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildCreateRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildCreateRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x55;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 44;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the guild name.
    /// </summary>
    public string GuildName
    {
        get => this._data.ExtractString(4, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 8).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the guild emblem in a custom bitmap format. It supports 16 colors (one transparent) per pixel and has a size of 8 * 8 pixel.
    /// </summary>
    public Span<byte> GuildEmblem
    {
        get => this._data.Slice(12, 32);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildCreateRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildCreateRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildCreateRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildCreateRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: When a player wants to create a guild.
/// Causes reaction on server side: The guild is created and the player is set as the new guild master of the guild.
/// </summary>
public readonly ref struct GuildCreateRequest075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildCreateRequest075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildCreateRequest075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildCreateRequest075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildCreateRequest075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x55;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 43;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the guild name.
    /// </summary>
    public string GuildName
    {
        get => this._data.ExtractString(3, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 8).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the guild emblem in a custom bitmap format. It supports 16 colors (one transparent) per pixel and has a size of 8 * 8 pixel.
    /// </summary>
    public Span<byte> GuildEmblem
    {
        get => this._data.Slice(11, 32);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildCreateRequest075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildCreateRequest075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildCreateRequest075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildCreateRequest075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player has the dialog of the guild master NPC opened and decided about its next step.
/// Causes reaction on server side: It either cancels the guild creation or proceeds with the guild creation dialog where the player can enter the guild name and symbol.
/// </summary>
public readonly ref struct GuildMasterAnswerRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildMasterAnswerRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildMasterAnswerRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildMasterAnswerRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildMasterAnswerRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x54;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets a value whether the guild creation dialog should be shown. Otherwise, the guild creation is cancelled and the dialog was closed.
    /// </summary>
    public bool ShowCreationDialog
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildMasterAnswer"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildMasterAnswerRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildMasterAnswer"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildMasterAnswerRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player has the dialog of the guild creation dialog opened and decided against creating a guild.
/// Causes reaction on server side: It either cancels the guild creation.
/// </summary>
public readonly ref struct CancelGuildCreationRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CancelGuildCreationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CancelGuildCreationRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CancelGuildCreationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CancelGuildCreationRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x57;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CancelGuildCreation"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CancelGuildCreationRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CancelGuildCreation"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CancelGuildCreationRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A guild master requested a guild war against another guild.
/// Causes reaction on server side: If the guild master confirms, the war is declared.
/// </summary>
public readonly ref struct GuildWarResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildWarResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildWarResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x61;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the accepted.
    /// </summary>
    public bool Accepted
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildWarResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildWarResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildWarResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildWarResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player gets another player into view range which is in a guild, and the guild identifier is unknown (=not cached yet by previous requests) to him.
/// Causes reaction on server side: The server sends a response which includes the guild name and emblem.
/// </summary>
public readonly ref struct GuildInfoRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildInfoRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildInfoRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildInfoRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildInfoRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x66;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the guild id.
    /// </summary>
    public uint GuildId
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildInfoRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildInfoRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildInfoRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildInfoRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A guild master wants to change the role of a guild member.
/// Causes reaction on server side: The server changes the role of the guild member.
/// </summary>
public readonly ref struct GuildRoleAssignRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildRoleAssignRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildRoleAssignRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildRoleAssignRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildRoleAssignRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.Type = 1;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xE1;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 15;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets unknown value between 1 and 3.
    /// </summary>
    public byte Type
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the role.
    /// </summary>
    public ServerToClient.GuildMemberRole Role
    {
        get => (ServerToClient.GuildMemberRole)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the player name.
    /// </summary>
    public string PlayerName
    {
        get => this._data.ExtractString(5, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(5, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildRoleAssignRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildRoleAssignRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildRoleAssignRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildRoleAssignRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A guild master wants to change the type of its guild. Didn't find any place in the client where this is sent.
/// Causes reaction on server side: The server changes the kind of the guild. We assume it's whether the guild should be the main guild of an alliance, or not. Shouldn't be handled, because this is constant for the lifetime of an alliance.
/// </summary>
public readonly ref struct GuildTypeChangeRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildTypeChangeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildTypeChangeRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildTypeChangeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildTypeChangeRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xE2;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets 0 = Common, 1 = Guard, FF = None.
    /// </summary>
    public byte GuildType
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildTypeChangeRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildTypeChangeRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildTypeChangeRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildTypeChangeRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A guild master sends a request to another guild master about changing the relationship between their guilds.
/// Causes reaction on server side: The server sends a response with the result.
/// </summary>
public readonly ref struct GuildRelationshipChangeRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildRelationshipChangeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildRelationshipChangeRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildRelationshipChangeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildRelationshipChangeRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xE5;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the relationship type.
    /// </summary>
    public GuildRelationshipType RelationshipType
    {
        get => (GuildRelationshipType)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the request type.
    /// </summary>
    public GuildRequestType RequestType
    {
        get => (GuildRequestType)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the target player id.
    /// </summary>
    public ushort TargetPlayerId
    {
        get => ReadUInt16LittleEndian(this._data[5..]);
        set => WriteUInt16LittleEndian(this._data[5..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildRelationshipChangeRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildRelationshipChangeRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildRelationshipChangeRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildRelationshipChangeRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A guild master answered the request to another guild master about changing the relationship between their guilds.
/// Causes reaction on server side: The server sends a response back to the requester. If the guild master agreed, it takes the necessary actions.
/// </summary>
public readonly ref struct GuildRelationshipChangeResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildRelationshipChangeResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildRelationshipChangeResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildRelationshipChangeResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildRelationshipChangeResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xE6;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the relationship type.
    /// </summary>
    public GuildRelationshipType RelationshipType
    {
        get => (GuildRelationshipType)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the request type.
    /// </summary>
    public GuildRequestType RequestType
    {
        get => (GuildRequestType)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the response.
    /// </summary>
    public bool Response
    {
        get => this._data[5..].GetBoolean();
        set => this._data[5..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the target player id.
    /// </summary>
    public ushort TargetPlayerId
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildRelationshipChangeResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildRelationshipChangeResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildRelationshipChangeResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildRelationshipChangeResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player opens the alliance list dialog.
/// Causes reaction on server side: The server answers with the list of the guilds of the alliance.
/// </summary>
public readonly ref struct RequestAllianceListRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RequestAllianceListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RequestAllianceListRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RequestAllianceListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RequestAllianceListRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xE9;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="RequestAllianceList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RequestAllianceListRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RequestAllianceList"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(RequestAllianceListRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: An alliance guild master wants to remove a guild from the alliance.
/// Causes reaction on server side: The server removes the guild from the alliance.
/// </summary>
public readonly ref struct RemoveAllianceGuildRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RemoveAllianceGuildRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RemoveAllianceGuildRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RemoveAllianceGuildRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RemoveAllianceGuildRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xEB;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the guild name.
    /// </summary>
    public string GuildName
    {
        get => this._data.ExtractString(4, this._data.Length - 4, System.Text.Encoding.UTF8);
        set => this._data.Slice(4).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="RemoveAllianceGuildRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RemoveAllianceGuildRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RemoveAllianceGuildRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(RemoveAllianceGuildRequestRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'GuildName' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 4;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'GuildName' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 4;
}


/// <summary>
/// Is sent by the client when: After the server sent a ping request.
/// Causes reaction on server side: The server knows the latency between server and client.
/// </summary>
public readonly ref struct PingResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PingResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PingResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PingResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PingResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x71;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PingResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PingResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PingResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PingResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player wants to repair an item of his inventory, either himself or with the usage of an NPC.
/// Causes reaction on server side: If the item is damaged and repairable, the durability of the item is maximized and corresponding responses are sent back to the client.
/// </summary>
public readonly ref struct ItemRepairRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemRepairRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemRepairRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemRepairRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemRepairRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x34;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the inventory slot of the target item. If it's 0xFF, the player requests to repair all items with the help of an NPC. If it's 8 (Pet slot), using the pet trainer NPC is mandatory, too.
    /// </summary>
    public byte InventoryItemSlot
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemRepair"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemRepairRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemRepair"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ItemRepairRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player has the dialog of the chaos machine open and decided to mix (craft) the items which he put into the chaos machine dialog.
/// Causes reaction on server side: Based on the type of mix and it's corresponding success rate, the mix succeeds or fails. The client gets a corresponding response with the created, changed or lost items.
/// </summary>
public readonly ref struct ChaosMachineMixRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ChaosMachineMixRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ChaosMachineMixRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ChaosMachineMixRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ChaosMachineMixRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x86;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the identifier which tells the server which kind of mix should be executed.
    /// </summary>
    public ChaosMachineMixRequest.ChaosMachineMixType MixType
    {
        get => (ChaosMachineMixRequest.ChaosMachineMixType)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the 0-based slot index of the socket at which a seed sphere should be mounted or removed. May only be available for the corresponding mixes, so access with care.
    /// </summary>
    public byte SocketSlot
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ChaosMachineMixRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ChaosMachineMixRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ChaosMachineMixRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ChaosMachineMixRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player closes the dialog which was opened by an interaction with the chaos machine goblin.
/// Causes reaction on server side: The server updates the state of the player accordingly.
/// </summary>
public readonly ref struct CraftingDialogCloseRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CraftingDialogCloseRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CraftingDialogCloseRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CraftingDialogCloseRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CraftingDialogCloseRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x87;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CraftingDialogCloseRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CraftingDialogCloseRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CraftingDialogCloseRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CraftingDialogCloseRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The client requests the current friend list.
/// Causes reaction on server side: The server sends the friend list to the client.
/// </summary>
public readonly ref struct FriendListRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FriendListRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private FriendListRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC0;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendListRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator FriendListRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="FriendListRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(FriendListRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player wants to add another players character into his friend list of the messenger.
/// Causes reaction on server side: A request is sent to the other player. If the player is currently offline, the request will be sent as soon as he is online again.
/// </summary>
public readonly ref struct FriendAddRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendAddRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FriendAddRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendAddRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private FriendAddRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC1;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the friend name.
    /// </summary>
    public string FriendName
    {
        get => this._data.ExtractString(3, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendAddRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator FriendAddRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="FriendAddRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(FriendAddRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player wants to delete another players character from his friend list of the messenger.
/// Causes reaction on server side: The entry in the friend list is removed. The player is shown as offline in the other players friends list.
/// </summary>
public readonly ref struct FriendDeleteRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendDeleteRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FriendDeleteRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendDeleteRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private FriendDeleteRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC3;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the friend name.
    /// </summary>
    public string FriendName
    {
        get => this._data.ExtractString(3, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendDelete"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator FriendDeleteRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="FriendDelete"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(FriendDeleteRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player wants to open a chat with another player of his friend list.
/// Causes reaction on server side: If both players are online, a chat room is created on the chat server. Authentication data is sent to both game clients, which will then try to connect to the chat server using this data.
/// </summary>
public readonly ref struct ChatRoomCreateRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ChatRoomCreateRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ChatRoomCreateRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ChatRoomCreateRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ChatRoomCreateRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xCA;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the friend name.
    /// </summary>
    public string FriendName
    {
        get => this._data.ExtractString(3, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ChatRoomCreateRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ChatRoomCreateRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ChatRoomCreateRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ChatRoomCreateRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player received a friend request from another player and responded to it.
/// Causes reaction on server side: If the player accepted, the friend is added to the players friend list and both players get subscribed about each others online status.
/// </summary>
public readonly ref struct FriendAddResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendAddResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FriendAddResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendAddResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private FriendAddResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC2;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 14;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the accepted.
    /// </summary>
    public bool Accepted
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the friend requester name.
    /// </summary>
    public string FriendRequesterName
    {
        get => this._data.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendAddResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator FriendAddResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="FriendAddResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(FriendAddResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player wants to set himself on- or offline.
/// Causes reaction on server side: Depending on the state, the player is shown as offline or online in all friend lists of his friends.
/// </summary>
public readonly ref struct SetFriendOnlineStateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SetFriendOnlineStateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SetFriendOnlineStateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SetFriendOnlineStateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SetFriendOnlineStateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC4;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the online state.
    /// </summary>
    public bool OnlineState
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SetFriendOnlineState"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SetFriendOnlineStateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SetFriendOnlineState"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SetFriendOnlineStateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player wants to invite additional players from his friend list to an existing chat room.
/// Causes reaction on server side: The player additional gets authentication data sent to his game client. It then connects to the chat server and joins the chat room.
/// </summary>
public readonly ref struct ChatRoomInvitationRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ChatRoomInvitationRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ChatRoomInvitationRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ChatRoomInvitationRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ChatRoomInvitationRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xCB;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 19;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the friend name.
    /// </summary>
    public string FriendName
    {
        get => this._data.ExtractString(3, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the room id.
    /// </summary>
    public ushort RoomId
    {
        get => ReadUInt16BigEndian(this._data[13..]);
        set => WriteUInt16BigEndian(this._data[13..], value);
    }

    /// <summary>
    /// Gets or sets the request id.
    /// </summary>
    public uint RequestId
    {
        get => ReadUInt32BigEndian(this._data[15..]);
        set => WriteUInt32BigEndian(this._data[15..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ChatRoomInvitationRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ChatRoomInvitationRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ChatRoomInvitationRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ChatRoomInvitationRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: After the player entered the game world with a character.
/// Causes reaction on server side: The quest state is sent back as response.
/// </summary>
public readonly ref struct LegacyQuestStateRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestStateRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LegacyQuestStateRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestStateRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LegacyQuestStateRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA0;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LegacyQuestStateRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LegacyQuestStateRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LegacyQuestStateRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LegacyQuestStateRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player wants to change the state of a quest, e.g. to start or to finish a quest.
/// Causes reaction on server side: Depending on the requested new state, a response is sent back.
/// </summary>
public readonly ref struct LegacyQuestStateSetRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestStateSetRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LegacyQuestStateSetRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestStateSetRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LegacyQuestStateSetRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA2;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest number.
    /// </summary>
    public byte QuestNumber
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the new state.
    /// </summary>
    public LegacyQuestState NewState
    {
        get => (LegacyQuestState)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LegacyQuestStateSetRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LegacyQuestStateSetRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LegacyQuestStateSetRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LegacyQuestStateSetRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player wants to command its equipped pet (raven).
/// Causes reaction on server side: 
/// </summary>
public readonly ref struct PetCommandRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PetCommandRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PetCommandRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PetCommandRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PetCommandRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA7;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the pet type.
    /// </summary>
    public PetType PetType
    {
        get => (PetType)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the command mode.
    /// </summary>
    public PetCommandMode CommandMode
    {
        get => (PetCommandMode)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PetCommandRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PetCommandRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PetCommandRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PetCommandRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player hovers over a pet. The client sends this request to retrieve information (level, experience) of the pet (dark raven, horse).
/// Causes reaction on server side: The server sends a PetInfoResponse.
/// </summary>
public readonly ref struct PetInfoRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PetInfoRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PetInfoRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PetInfoRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PetInfoRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA9;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the pet.
    /// </summary>
    public PetType Pet
    {
        get => (PetType)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the storage.
    /// </summary>
    public StorageType Storage
    {
        get => (StorageType)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the item slot.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PetInfoRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PetInfoRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PetInfoRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PetInfoRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The client has the NPC dialog for the illusion temple opened, and wants to enter the event map.
/// Causes reaction on server side: The server checks if the player has the required ticket and moves the player to the event map.
/// </summary>
public readonly ref struct IllusionTempleEnterRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleEnterRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleEnterRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleEnterRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleEnterRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the map number.
    /// </summary>
    public byte MapNumber
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the item slot.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="IllusionTempleEnterRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleEnterRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleEnterRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(IllusionTempleEnterRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player is in the illusion temple event and wants to perform a special skill (210 - 213), Order of Protection, Restraint, Tracking or Weaken.
/// Causes reaction on server side: The server checks if the player is inside the event etc. and performs the skills accordingly.
/// </summary>
public readonly ref struct IllusionTempleSkillRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleSkillRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleSkillRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleSkillRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleSkillRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill number.
    /// </summary>
    public ushort SkillNumber
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the target object index.
    /// </summary>
    public byte TargetObjectIndex
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the distance.
    /// </summary>
    public byte Distance
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="IllusionTempleSkillRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleSkillRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleSkillRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(IllusionTempleSkillRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player requests the reward of the event.
/// Causes reaction on server side: The server checks if the player is in the winning game and returns a reward, usually as item drop.
/// </summary>
public readonly ref struct IllusionTempleRewardRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleRewardRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleRewardRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleRewardRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleRewardRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x05;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="IllusionTempleRewardRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleRewardRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleRewardRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(IllusionTempleRewardRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player has the lucky coin dialog open and requests the current count of the registered coins.
/// Causes reaction on server side: The server returns the count of the registered coins.
/// </summary>
public readonly ref struct LuckyCoinCountRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LuckyCoinCountRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LuckyCoinCountRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LuckyCoinCountRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LuckyCoinCountRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LuckyCoinCountRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LuckyCoinCountRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LuckyCoinCountRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LuckyCoinCountRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player has the lucky coin dialog open and requests to register one lucky coin, which is in his inventory.
/// Causes reaction on server side: The server returns the result of the registration increases the coin count and decreases the coin durability by one.
/// </summary>
public readonly ref struct LuckyCoinRegistrationRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LuckyCoinRegistrationRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LuckyCoinRegistrationRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LuckyCoinRegistrationRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LuckyCoinRegistrationRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0C;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LuckyCoinRegistrationRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LuckyCoinRegistrationRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LuckyCoinRegistrationRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LuckyCoinRegistrationRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player has the lucky coin dialog open and requests an exchange for the specified number of registered coins.
/// Causes reaction on server side: The server adds an item to the inventory of the character and sends a response with a result code.
/// </summary>
public readonly ref struct LuckyCoinExchangeRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LuckyCoinExchangeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LuckyCoinExchangeRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LuckyCoinExchangeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LuckyCoinExchangeRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0D;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the coin count.
    /// </summary>
    public uint CoinCount
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LuckyCoinExchangeRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LuckyCoinExchangeRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LuckyCoinExchangeRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LuckyCoinExchangeRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player wants to enter the doppelganger event.
/// Causes reaction on server side: The server checks the event ticket and moves the player to the event map.
/// </summary>
public readonly ref struct DoppelgangerEnterRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DoppelgangerEnterRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DoppelgangerEnterRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DoppelgangerEnterRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DoppelgangerEnterRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0E;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the ticket item slot.
    /// </summary>
    public byte TicketItemSlot
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DoppelgangerEnterRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DoppelgangerEnterRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DoppelgangerEnterRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DoppelgangerEnterRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player wants to enter the market place map.
/// Causes reaction on server side: The server moves the player to the market place map.
/// </summary>
public readonly ref struct EnterMarketPlaceRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="EnterMarketPlaceRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public EnterMarketPlaceRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="EnterMarketPlaceRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private EnterMarketPlaceRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x17;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="EnterMarketPlaceRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator EnterMarketPlaceRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="EnterMarketPlaceRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(EnterMarketPlaceRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The client clicked on MU Helper play or pause button.
/// Causes reaction on server side: The server validates, if user can use the helper and sends the status back.
/// </summary>
public readonly ref struct MuHelperStatusChangeRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MuHelperStatusChangeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MuHelperStatusChangeRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MuHelperStatusChangeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MuHelperStatusChangeRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x51;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the pause status.
    /// </summary>
    public bool PauseStatus
    {
        get => this._data[4..].GetBoolean();
        set => this._data[4..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MuHelperStatusChangeRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MuHelperStatusChangeRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MuHelperStatusChangeRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MuHelperStatusChangeRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The client want to save current MU Helper data.
/// Causes reaction on server side: The server should save supplied MU Helper data.
/// </summary>
public readonly ref struct MuHelperSaveDataRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MuHelperSaveDataRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MuHelperSaveDataRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MuHelperSaveDataRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MuHelperSaveDataRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAE;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 261;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the helper data.
    /// </summary>
    public Span<byte> HelperData
    {
        get => this._data.Slice(4, 257);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MuHelperSaveDataRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MuHelperSaveDataRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MuHelperSaveDataRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MuHelperSaveDataRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The client opened an quest NPC dialog and selected an available quests.
/// Causes reaction on server side: If the quest is already active, it responds with the QuestProgress. If the quest is inactive, the server decides if the character can start the quest and responds with a QuestStepInfo with the StartingNumber. A character can run up to 3 concurrent quests at a time.
/// </summary>
public readonly ref struct QuestSelectRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestSelectRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestSelectRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestSelectRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestSelectRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0A;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest number.
    /// </summary>
    public ushort QuestNumber
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the quest group.
    /// </summary>
    public ushort QuestGroup
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets a 1-based index of the selected index in the dialog. It's 0 when no text has been selected. It's not clear yet, when we need that.
    /// </summary>
    public byte SelectedTextIndex
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestSelectRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestSelectRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestSelectRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(QuestSelectRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: After the server started a quest (and sent a F60B message) the game client requests to proceed with the quest.
/// Causes reaction on server side: The quest state is set accordingly on the server. The next response seems to depend on the quest configuration. Depending on the action of the next quest state, the server will send either a quest progress message (F60C) or again a quest start message (F60B).
/// </summary>
public readonly ref struct QuestProceedRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestProceedRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestProceedRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestProceedRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestProceedRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest number.
    /// </summary>
    public ushort QuestNumber
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the quest group.
    /// </summary>
    public ushort QuestGroup
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the proceed action.
    /// </summary>
    public QuestProceedRequest.QuestProceedAction ProceedAction
    {
        get => (QuestProceedRequest.QuestProceedAction)this._data[8];
        set => this._data[8] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestProceedRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestProceedRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestProceedRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(QuestProceedRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The game client requests to complete an active quest.
/// Causes reaction on server side: The server checks the conditions to complete the quest. If this fails, nothing happens. If all conditions are met, the reward is given to the player and the quest state is set accordingly, so that the player can select to start the next quest. Additionally, the quest completion response message (F60D) is sent to the client.
/// </summary>
public readonly ref struct QuestCompletionRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestCompletionRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestCompletionRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestCompletionRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestCompletionRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0D;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest number.
    /// </summary>
    public ushort QuestNumber
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the quest group.
    /// </summary>
    public ushort QuestGroup
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestCompletionRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestCompletionRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestCompletionRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(QuestCompletionRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The game client requests to cancel an active quest.
/// Causes reaction on server side: The server checks if the quest is currently in progress. In this case, the quest state is reset and a response (F60F) is sent back to the client.
/// </summary>
public readonly ref struct QuestCancelRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestCancelRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestCancelRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestCancelRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestCancelRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0F;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest number.
    /// </summary>
    public ushort QuestNumber
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the quest group.
    /// </summary>
    public ushort QuestGroup
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestCancelRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestCancelRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestCancelRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(QuestCancelRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The game client requests to complete a client action, e.g. completing a tutorial.
/// Causes reaction on server side: The server checks if the specified quest is currently in progress. If the quest got a Condition (condition type 0x10) for this flag, the condition is flagged as fulfilled.
/// </summary>
public readonly ref struct QuestClientActionRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestClientActionRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestClientActionRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestClientActionRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestClientActionRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x10;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest number.
    /// </summary>
    public ushort QuestNumber
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the quest group.
    /// </summary>
    public ushort QuestGroup
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestClientActionRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestClientActionRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestClientActionRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(QuestClientActionRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The clients requests the states of all quests, usually after entering the game.
/// Causes reaction on server side: The list of active quests is sent back (F61A) without changing any state. This list just contains all running or completed quests for each group.
/// </summary>
public readonly ref struct ActiveQuestListRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ActiveQuestListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ActiveQuestListRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ActiveQuestListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ActiveQuestListRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x1A;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ActiveQuestListRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ActiveQuestListRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ActiveQuestListRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ActiveQuestListRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The game client requests the state of a specific active quests.
/// Causes reaction on server side: The quest state is sent back (F61B) without changing any state, if the quest is currently in progress.
/// </summary>
public readonly ref struct QuestStateRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestStateRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestStateRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestStateRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestStateRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x1B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest number.
    /// </summary>
    public ushort QuestNumber
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the quest group.
    /// </summary>
    public ushort QuestGroup
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestStateRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestStateRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestStateRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(QuestStateRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The game client requests the list of event quests, usually after entering the game.
/// Causes reaction on server side: The server may answer with a response which seems to depend if the character is member of a Gen or not. If it's not in a gen, it sends a response (F603).
/// </summary>
public readonly ref struct EventQuestStateListRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="EventQuestStateListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public EventQuestStateListRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="EventQuestStateListRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private EventQuestStateListRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x21;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="EventQuestStateListRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator EventQuestStateListRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="EventQuestStateListRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(EventQuestStateListRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The client opened an quest NPC dialog and requests a list of available quests.
/// Causes reaction on server side: The list of available quests of this NPC is sent back (F60A).
/// </summary>
public readonly ref struct AvailableQuestsRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AvailableQuestsRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AvailableQuestsRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AvailableQuestsRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AvailableQuestsRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x30;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AvailableQuestsRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AvailableQuestsRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AvailableQuestsRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AvailableQuestsRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The game client requests to get a buff from the currently interacting quest npc. As far as we know, only the Elf Soldier NPC offers such a buff until a certain character level (150 or 220).
/// Causes reaction on server side: The server should check if the correct Quest NPC (e.g. Elf Soldier) dialog is opened and the player didn't reach the level limit yet. If that's both the case, it adds a defined buff (MagicEffect) to the player; Otherwise, a message is sent to the player.
/// </summary>
public readonly ref struct NpcBuffRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcBuffRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public NpcBuffRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcBuffRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private NpcBuffRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x31;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="NpcBuffRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator NpcBuffRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="NpcBuffRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(NpcBuffRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player wants to enter the empire guardian event due an npc dialog.
/// Causes reaction on server side: The checks if the player can enter the event, and moves it to the event, if possible.
/// </summary>
public readonly ref struct EnterEmpireGuardianEventRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="EnterEmpireGuardianEventRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public EnterEmpireGuardianEventRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="EnterEmpireGuardianEventRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private EnterEmpireGuardianEventRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.ItemSlot = 01;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF7;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the item slot of the event ticket. Not used by the server.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="EnterEmpireGuardianEvent"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator EnterEmpireGuardianEventRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="EnterEmpireGuardianEvent"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(EnterEmpireGuardianEventRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player has opened one of the gens NPCs and requests to join it.
/// Causes reaction on server side: The server checks if the player is not in a gens already and joins the player to the selected gens.
/// </summary>
public readonly ref struct GensJoinRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GensJoinRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GensJoinRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GensJoinRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GensJoinRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF8;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the gens type.
    /// </summary>
    public GensType GensType
    {
        get => (GensType)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GensJoinRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GensJoinRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GensJoinRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GensJoinRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player wants to leave the current gens.
/// Causes reaction on server side: The server the player from the gens.
/// </summary>
public readonly ref struct GensLeaveRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GensLeaveRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GensLeaveRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GensLeaveRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GensLeaveRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF8;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GensLeaveRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GensLeaveRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GensLeaveRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GensLeaveRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The game client requests to get a reward from the gens npc.
/// Causes reaction on server side: The server checks if the player has enough points to get the reward, and sends a response.
/// </summary>
public readonly ref struct GensRewardRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GensRewardRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GensRewardRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GensRewardRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GensRewardRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF8;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x09;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the gens type.
    /// </summary>
    public GensType GensType
    {
        get => (GensType)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GensRewardRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GensRewardRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GensRewardRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GensRewardRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The game client requests information about the current gens ranking.
/// Causes reaction on server side: The server returns the current gens rankinginformation.
/// </summary>
public readonly ref struct GensRankingRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GensRankingRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GensRankingRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GensRankingRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GensRankingRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF8;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GensRankingRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GensRankingRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GensRankingRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GensRankingRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player requests to enter the devil square through the Charon NPC.
/// Causes reaction on server side: The server checks if the player can enter the event and sends a response (Code 0x90) back to the client. If it was successful, the character gets moved to the event map.
/// </summary>
public readonly ref struct DevilSquareEnterRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DevilSquareEnterRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DevilSquareEnterRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DevilSquareEnterRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DevilSquareEnterRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x90;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the level of the devil square, minus 1.
    /// </summary>
    public byte SquareLevel
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the index of the ticket item in the inventory. Be aware, that the value is 12 higher than it should be - it makes no sense, but it is what it is...
    /// </summary>
    public byte TicketItemInventoryIndex
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DevilSquareEnterRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DevilSquareEnterRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DevilSquareEnterRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DevilSquareEnterRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player requests to get the remaining time of the currently entered event.
/// Causes reaction on server side: The remaining time is sent back to the client.
/// </summary>
public readonly ref struct MiniGameOpeningStateRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MiniGameOpeningStateRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MiniGameOpeningStateRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MiniGameOpeningStateRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MiniGameOpeningStateRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x91;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the event type.
    /// </summary>
    public MiniGameType EventType
    {
        get => (MiniGameType)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the event level.
    /// </summary>
    public byte EventLevel
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MiniGameOpeningStateRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MiniGameOpeningStateRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MiniGameOpeningStateRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MiniGameOpeningStateRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player registers an event item at an NPC, usually the golden archer.
/// Causes reaction on server side: A response is sent back to the client with the current event chip count.
/// </summary>
public readonly ref struct EventChipRegistrationRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="EventChipRegistrationRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public EventChipRegistrationRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="EventChipRegistrationRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private EventChipRegistrationRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x95;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the item index.
    /// </summary>
    public byte ItemIndex
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="EventChipRegistrationRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator EventChipRegistrationRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="EventChipRegistrationRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(EventChipRegistrationRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player requests information about the Muto number. Unused.
/// Causes reaction on server side: A response is sent back to the client with the current Muto number.
/// </summary>
public readonly ref struct MutoNumberRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MutoNumberRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MutoNumberRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MutoNumberRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MutoNumberRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x96;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MutoNumberRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MutoNumberRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MutoNumberRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MutoNumberRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player requests to close the event chip dialog.
/// Causes reaction on server side: The event chip dialog will be closed.
/// </summary>
public readonly ref struct EventChipExitDialogRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="EventChipExitDialogRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public EventChipExitDialogRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="EventChipExitDialogRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private EventChipExitDialogRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x97;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="EventChipExitDialog"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator EventChipExitDialogRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="EventChipExitDialog"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(EventChipExitDialogRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player requests to exchange the event chips to something else.
/// Causes reaction on server side: A response is sent back to the client with the exchange result.
/// </summary>
public readonly ref struct EventChipExchangeRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="EventChipExchangeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public EventChipExchangeRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="EventChipExchangeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private EventChipExchangeRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x98;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="EventChipExchangeRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator EventChipExchangeRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="EventChipExchangeRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(EventChipExchangeRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: Unknown?
/// Causes reaction on server side: Unknown?
/// </summary>
public readonly ref struct ServerImmigrationRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ServerImmigrationRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ServerImmigrationRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ServerImmigrationRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ServerImmigrationRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x99;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the security code.
    /// </summary>
    public string SecurityCode
    {
        get => this._data.ExtractString(3, this._data.Length - 3, System.Text.Encoding.UTF8);
        set => this._data.Slice(3).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ServerImmigrationRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ServerImmigrationRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ServerImmigrationRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ServerImmigrationRequestRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'SecurityCode' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 3;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'SecurityCode' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 3;
}


/// <summary>
/// Is sent by the client when: The player requests to redeem a coupon code (lucky number) which is 12 alphanumeric digits long.
/// Causes reaction on server side: A response is sent back to the client with the result. An item could be rewarded to the inventory.
/// </summary>
public readonly ref struct LuckyNumberRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LuckyNumberRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LuckyNumberRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LuckyNumberRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LuckyNumberRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x9D;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 18;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the serial 1.
    /// </summary>
    public string Serial1
    {
        get => this._data.ExtractString(3, 4, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 4).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the serial 2.
    /// </summary>
    public string Serial2
    {
        get => this._data.ExtractString(8, 4, System.Text.Encoding.UTF8);
        set => this._data.Slice(8, 4).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the serial 3.
    /// </summary>
    public string Serial3
    {
        get => this._data.ExtractString(13, 4, System.Text.Encoding.UTF8);
        set => this._data.Slice(13, 4).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LuckyNumberRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LuckyNumberRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LuckyNumberRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LuckyNumberRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player requests to enter the blood castle through the Archangel Messenger NPC.
/// Causes reaction on server side: The server checks if the player can enter the event and sends a response (Code 0x9A) back to the client. If it was successful, the character gets moved to the event map.
/// </summary>
public readonly ref struct BloodCastleEnterRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="BloodCastleEnterRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public BloodCastleEnterRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="BloodCastleEnterRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private BloodCastleEnterRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x9A;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the level of the battle square.
    /// </summary>
    public byte CastleLevel
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the index of the ticket item in the inventory. Be aware, that the value is 12 higher than it should be - it makes no sense, but it is what it is...
    /// </summary>
    public byte TicketItemInventoryIndex
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="BloodCastleEnterRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator BloodCastleEnterRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="BloodCastleEnterRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(BloodCastleEnterRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player requests to get the entering count of the specified mini game.
/// Causes reaction on server side: The remaining time is sent back to the client. However, it's not really handled on the known server sources.
/// </summary>
public readonly ref struct MiniGameEventCountRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MiniGameEventCountRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MiniGameEventCountRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MiniGameEventCountRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MiniGameEventCountRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x9F;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the mini game.
    /// </summary>
    public MiniGameType MiniGame
    {
        get => (MiniGameType)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MiniGameEventCountRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MiniGameEventCountRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MiniGameEventCountRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MiniGameEventCountRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player requests to enter the chaos castle by using the 'Armor of Guardsman' item.
/// Causes reaction on server side: The server checks if the player can enter the event and sends a response (Code 0xAF) back to the client. If it was successful, the character gets moved to the event map.
/// </summary>
public readonly ref struct ChaosCastleEnterRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ChaosCastleEnterRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ChaosCastleEnterRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ChaosCastleEnterRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ChaosCastleEnterRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the level of the chaos castle. Appears to always be 0.
    /// </summary>
    public byte CastleLevel
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the index of the ticket item in the inventory.
    /// </summary>
    public byte TicketItemInventoryIndex
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ChaosCastleEnterRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ChaosCastleEnterRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ChaosCastleEnterRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ChaosCastleEnterRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The game client noticed, that the coordinates of the player is not on the ground anymore. It requests to set the specified coordinates.
/// Causes reaction on server side: The server sets the player on the new coordinates. Not handled on OpenMU.
/// </summary>
public readonly ref struct ChaosCastlePositionSetRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ChaosCastlePositionSetRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ChaosCastlePositionSetRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ChaosCastlePositionSetRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ChaosCastlePositionSetRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ChaosCastlePositionSet"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ChaosCastlePositionSetRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ChaosCastlePositionSet"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ChaosCastlePositionSetRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: The player requests to start a duel with another player.
/// Causes reaction on server side: The server sends a request to the other player.
/// </summary>
public readonly ref struct DuelStartRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelStartRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelStartRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelStartRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelStartRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 16;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the player name.
    /// </summary>
    public string PlayerName
    {
        get => this._data.ExtractString(6, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(6, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DuelStartRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelStartRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelStartRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DuelStartRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player requested to start a duel with the sending player.
/// Causes reaction on server side: Depending on the response, the server starts the duel, or not.
/// </summary>
public readonly ref struct DuelStartResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelStartResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelStartResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelStartResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelStartResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 16;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the response.
    /// </summary>
    public bool Response
    {
        get => this._data[4..].GetBoolean();
        set => this._data[4..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Gets or sets the player name.
    /// </summary>
    public string PlayerName
    {
        get => this._data.ExtractString(7, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(7, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DuelStartResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelStartResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelStartResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DuelStartResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player requested to stop the duel.
/// Causes reaction on server side: The server stops the duel.
/// </summary>
public readonly ref struct DuelStopRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelStopRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelStopRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelStopRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelStopRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DuelStopRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelStopRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelStopRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DuelStopRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player requested to join the duel as a spectator.
/// Causes reaction on server side: The server will add the player as spectator.
/// </summary>
public readonly ref struct DuelChannelJoinRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelChannelJoinRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelChannelJoinRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelChannelJoinRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelChannelJoinRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x07;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the channel id.
    /// </summary>
    public byte ChannelId
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DuelChannelJoinRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelChannelJoinRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelChannelJoinRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DuelChannelJoinRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the client when: A player requested to quit the duel as a spectator.
/// Causes reaction on server side: The server will remove the player as spectator.
/// </summary>
public readonly ref struct DuelChannelQuitRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelChannelQuitRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelChannelQuitRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelChannelQuitRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelChannelQuitRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x07;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the channel id.
    /// </summary>
    public byte ChannelId
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DuelChannelQuitRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelChannelQuitRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelChannelQuitRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DuelChannelQuitRequestRef packet) => packet._data; 
}
